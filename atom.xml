<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[bd17kaka's blog]]></title>
  <link href="http://zhangdian.github.com/atom.xml" rel="self"/>
  <link href="http://zhangdian.github.com/"/>
  <updated>2013-06-14T22:02:30+08:00</updated>
  <id>http://zhangdian.github.com/</id>
  <author>
    <name><![CDATA[bd17kaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java定时任务]]></title>
    <link href="http://zhangdian.github.com/blog/2013/06/14/java-schedule-task/"/>
    <updated>2013-06-14T21:56:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/06/14/java-schedule-task</id>
    <content type="html"><![CDATA[<h2>定时任务</h2>

<h3>关于定时任务</h3>

<p>定时任务有两种：</p>

<ul>
<li>固定延时的定时任务，即一个任务结束等待固定时间后再执行下一个；</li>
<li>固定频率的定时任务，即任务在固定时常后开始执行。</li>
</ul>


<p>前者的意思是，任务完成之后，等待固定的诗句再执行下一个；而后者的意思是在固定的时间执行任务，如果前一次任务的结束时间已经超过了下一次任务开始的时间，那么就会立即执行。</p>

<h3>定时任务实现方案</h3>

<p>Timer和ScheduledThreadPoolExecutor都可以完成定时任务的工作，也都支持上面的两种方式。</p>

<p>下面分别给出两个类的示例：</p>

<pre><code>package com.concurrent.basic;
import java.util.Timer;
import java.util.TimerTask;
public class TimerTest {
    private Timer timer = new Timer();

    // 启动计时器
    public void lanuchTimer() {
        timer.schedule(new TimerTask() {
            public void run() {
                // do sth...
            }
        }, 1000 * 3, 500);
    }

    public static void main(String[] args) throws Exception {
        TimerTest test = new TimerTest();
        test.lanuchTimer();
    }
}
</code></pre>

<p>这个例子是固定延时的任务，详细文档见<a href="http://docs.oracle.com/javase/7/docs/api/">Timer</a>，文档中，也有scheduleAtFixedRate方法来调用固定频率的任务。</p>

<pre><code>package com.concurrent.basic;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorTest {

    public ScheduledExecutorService scheduExec = Executors
            .newScheduledThreadPool(1);

    // 启动计时器
    public void lanuchTimer() {
        Runnable task = new Runnable() {
            public void run() {
                // do sth...
            }
        };
        scheduExec.scheduleWithFixedDelay(task, 1000 * 5, 1000 * 10,
                TimeUnit.MILLISECONDS);
    }

    public static void main(String[] args) throws Exception {
        ScheduledExecutorTest test = new ScheduledExecutorTest();
        test.lanuchTimer();
    }
}
</code></pre>

<p>这个例子是固定延时的任务示例，也可以调用scheduleAtFixedRate方法来启用固定频率的任务。</p>

<h3>比较</h3>

<ul>
<li>Timer对系统时钟是敏感的，而ScheduledThreadPoolExecutor不是；</li>
<li>Timer只有一个执行线程，所以如果一个线程延时太久了，会影响其他的固定延时任务。而ScheduledThreadPoolExecutor可以配置任意数量的线程，并且你可以完成控制你所创建的这些线程；</li>
<li><em>在Timer中，运行时错误会直接杀死线程，也就会导致线程挂掉，后面计划的任务也不会执行。ScheduledThreadPoolExecutor不仅可以给你catch住运行时异常，还可以对它们进行处理。抛出异常的任务会挂掉，但是其他的定时任务会继续执行。</em></li>
</ul>


<h3>相关链接</h3>

<ul>
<li><a href="http://marshal.easymorse.com/archives/3136">通过java concurrent实现定时任务</a></li>
<li><a href="http://batitan.iteye.com/blog/253483">定时任务:Java中Timer和TimerTask的使用</a></li>
<li><a href="http://stackoverflow.com/questions/409932/java-timer-vs-executorservice">Java Timer vs ExecutorService?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js cross domain post]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/28/js-cross-domain-post/"/>
    <updated>2013-05-28T00:47:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/28/js-cross-domain-post</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring WEB MVC总结]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/27/spring-web-mvc/"/>
    <updated>2013-05-27T00:26:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/27/spring-web-mvc</id>
    <content type="html"><![CDATA[<p>用了这么久的spring web，终于把官方的文档看了看，总结出来下面的文档。</p>

<!-- more -->


<h4>Spring WEB MVC的特性</h4>

<ul>
<li>角色分明：controller、validator、command object、form object、model object、DispatcherServlet、handler mapping、view resolver等等，每个角色都可以由一个专门的对象来实现；</li>
<li>框架和类似JavaBean应用类的强大而简单的配置；</li>
<li>适配性、非侵入性以及灵活性。可以任意定义controller方法的前面，对于指定的场景，可以使用@RequestParam、@RequestHeader、@PathVariable其中的一个；</li>
<li>可重用的业务代码；</li>
<li>可定制话的绑定和验证；</li>
<li>类型匹配错误作为应用层的验证错误，取代手动将传进来的String-Only对象parse and convert成为业务对象；</li>
<li>个性化handler mapping以及view resolution；</li>
<li>灵活的model解析。利用name/value Map，可以利用任意一种view技术解析model；</li>
<li>个性化的locale以及theme resolution。支持JSPs，包不包含Spring tag lib，JSTL都行；</li>
<li>等等</li>
</ul>


<h4>其他MVC实现的可插入性</h4>

<p>如果不想使用Spring web MVC，而是想在其他类似struts、WebWork的框架中使用Spring的某些特性，这也是可以的，具体的可以查看相关文档。</p>

<h4>1. DispatcherServlet类</h4>

<p>和其他的MVC框架一样，Spring web MVC也是基于<strong>请求驱动</strong>的模型，围绕一个核心的servlet，将所有的请求分发到Controllers，同时提供丰富的功能，来帮助web应用程序的开发。Spring完全集成Spring IoC容器，允许你使用Spring所拥有的任何特性。</p>

<p>下图是Spring web MVC中的请求处理流程图：</p>

<p><img src="https://dl.dropboxusercontent.com/u/99113526/blog.bd17kaka.net/spring-web-mvc.png"></p>

<p>DispatcherServlet是Servlet类的一个子类，继承自HttpServlet，它在web.xml文件中进行定义。需要通过使用URL映射，来将需要其处理的请求映射到这个Servlet。下面是一个标准的servlet配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- web.xml --&gt;
</span><span class='line'>&lt;web-app&gt;
</span><span class='line'>
</span><span class='line'>    &lt;servlet&gt;
</span><span class='line'>        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
</span><span class='line'>        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
</span><span class='line'>        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
</span><span class='line'>    &lt;/servlet&gt;
</span><span class='line'>
</span><span class='line'>    &lt;servlet-mapping&gt;
</span><span class='line'>        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
</span><span class='line'>        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
</span><span class='line'>    &lt;/servlet-mapping&gt;
</span><span class='line'>
</span><span class='line'>&lt;/web-app&gt;</span></code></pre></td></tr></table></div></figure>


<p>额外的参数：contextClass、contextConfigLocation、namespace，具体解释见原文。</p>

<p>在这个例子中，所有满足表达式“*.form”的请求，都将有servlet-name为“example”的这个servlet来进行处理。</p>

<p>在Spring中，ApplicationContext实例是有作用域的。在Web MVC架构中，每一个DispatcherServlet类都有它自己的WebApplicationContext，这个WebApplicationContext继承所有已经在根部的WebApplicationContext中所定义的beans。这些beans是可以被在servlet中定义的beans所覆盖的。（不太懂，得看看Spring Ioc）</p>

<p>在DispatcherServlet初始化的时候，Spring在文件夹WEB-INF中查找文件名为[servlet-name]-servlet.xml的文件，并且创建那个文件里面定义的所有beans。将在全局作用域中，有相同名称的bean全覆盖掉。</p>

<p>考虑上面的那个web.xml定义，那么需要在WEB-INF文件夹中，创建一个名为example-servlet.xml的文件，这个里面包含所有Spring WEB MVC所拥有的beans。</p>

<p><strong>我的理解是：一个web.xml文件中可以定义多个servlet；一个servlet对应一个example-servlet.xml文件；一个example-servlet.xml文件就是一个WebApplicationContext。</strong></p>

<p>在WebApplicationContext中，包含下面这些类型的beans：</p>

<ul>
<li>controllers</li>
<li>handler mappings</li>
<li>view resolvers</li>
<li>locale resolvers</li>
<li>theme resolver</li>
<li>multipart file resolver</li>
<li>handler exception resolvers</li>
</ul>


<p>当有一个请求到来的时候，DispatcherServlet是按照以下的顺序来处理这个请求的：</p>

<ul>
<li>搜索WebApplicationContext，并且将其作为一个attribute绑定到request中，这样，在这个过程中，controller和其他的元素都可以使用。默认情况下，它被绑定在DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE里面；</li>
<li>locale resolver绑定到request中，这样，其他的元素可以解析并使用locale（呈现view、准备数据等等）。如果你不需要locale resolving，那么就不需要他它；</li>
<li>theme resolver绑定到request中，允许views等元素决定使用哪个theme。如果不需要themes，可以忽略它；</li>
<li>如果指定了一个multipart file resolver，那么这个请求就被看做multipart。如果找到了multipart，就会将这个请求包装成一个MultipartHttpServletRequest，再由其它元素进行进一步的处理；</li>
<li>搜索一个合适的handler。如果找到了，那个和这个handler相关的执行链（preprocessors, postprocessors, and controllers）会被执行，以准备model以及呈现；</li>
<li>如果返回了一个model，那么会呈现一个view；如果没有model返回，那么不会呈现任何view，因为请求以及被执行完毕了。</li>
</ul>


<p>在WebApplicationContext中声明的Handler exception resolvers对象，接收在请求处理过程中产生的所有错误。用这些exception resolvers可以使对于不同的exception定义个性化的处理办法。</p>

<h4>2. Controllers</h4>

<p>controllers获取用户的输入，并且在处理之后，将其转换为model，进而转换为view，展现给用户。Spring提供的controller是非常抽象化的，可以定义各种各样、大量的controllers。</p>

<p>Spring2.5引入基于注解的编程模型，可以使用诸如@RequestMapping、@RequestParam、@ModelAttribute等注解。它同时支持Servlet MVC和Potlet MVC。这种情况下，不需要事先指定的基类或者指定的接口。下面是一个简单的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>public class HelloWorldController {
</span><span class='line'>
</span><span class='line'>    @RequestMapping("/helloWorld")
</span><span class='line'>    public ModelAndView helloWorld() {
</span><span class='line'>        ModelAndView mav = new ModelAndView();
</span><span class='line'>        mav.setViewName("helloWorld");
</span><span class='line'>        mav.addObject("message", "Hello World!");
</span><span class='line'>        return mav;
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h5>2.1 使用@controller定义一个controller</h5>

<p>@controller标签定义一个执行controller功能的类，在Spring里面，不需要继承任何的controller基类，或者调用ServletAPI，不过，如果有需要的话，也可以调用Servlet指定的特性。</p>

<p>@controller作为被注解的类的签名，标示这个类的角色。Dispatcher类扫描以@controller做注解的类，然后寻找以@RequestMapping做注解的方法。</p>

<p>我们可以严格的对controller类使用@controller注解，但是@controller标签页支持自动搜索，依赖于Spring支持在classpath中自动搜索组件类，以及为他们完成自动注册的bean的定义。</p>

<p>只需要将扫描组件添加到配置中，即可启用自动扫描这样的注解controller的功能：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</span><span class='line'>&lt;beans xmlns="http://www.springframework.org/schema/beans" 
</span><span class='line'>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
</span><span class='line'>    xmlns:p="http://www.springframework.org/schema/p" 
</span><span class='line'>    xmlns:context="http://www.springframework.org/schema/context"
</span><span class='line'>    xsi:schemaLocation="
</span><span class='line'>        http://www.springframework.org/schema/beans 
</span><span class='line'>        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
</span><span class='line'>        http://www.springframework.org/schema/context 
</span><span class='line'>        http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;
</span><span class='line'>
</span><span class='line'>    &lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/&gt;
</span><span class='line'>
</span><span class='line'>    // ...
</span><span class='line'>
</span><span class='line'>&lt;/beans&gt;</span></code></pre></td></tr></table></div></figure>


<h5>2.2 利用@RequestMapping来匹配请求</h5>

<p>我们可以用类似于“/handler”的注解来匹配整个类，也可以只匹配某个函数。比如，对于一个指定的HTTP请求（GET/POST）或者一个HTTP请求参数，我们经常用一个<strong>类级别</strong>的注解来将一个指定的请求映射到一个表单controller，然后使用一个额外的<strong>方法级别</strong>的注解来缩小范围。下面是一个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/handler")
</span><span class='line'>public class AppointmentsController {
</span><span class='line'>
</span><span class='line'>    private final AppointmentBook appointmentBook;
</span><span class='line'>    
</span><span class='line'>    @Autowired
</span><span class='line'>    public AppointmentsController(AppointmentBook appointmentBook) {
</span><span class='line'>        this.appointmentBook = appointmentBook;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @RequestMapping(method = RequestMethod.GET)
</span><span class='line'>    public Map&lt;String, Appointment&gt; get() {
</span><span class='line'>        return appointmentBook.getAppointmentsForToday();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @RequestMapping(value="/{day}", method = RequestMethod.GET)
</span><span class='line'>    public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) {
</span><span class='line'>        return appointmentBook.getAppointmentsForDay(day);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @RequestMapping(value="/new", method = RequestMethod.GET)
</span><span class='line'>    public AppointmentForm getNewForm() {
</span><span class='line'>        return new AppointmentForm();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @RequestMapping(method = RequestMethod.POST)
</span><span class='line'>    public String add(@Valid AppointmentForm appointment, BindingResult result) {
</span><span class='line'>        if (result.hasErrors()) {
</span><span class='line'>            return "appointments/new";
</span><span class='line'>        }
</span><span class='line'>        appointmentBook.addAppointment(appointment);
</span><span class='line'>        return "redirect:/appointments";
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>类级别的@RequestMapping注解并不是必须的，没有它的话，所有路径都是绝对路径，而不是相对路径。</p>

<p>这里有一个当使用proxy时，关于@controller注解类的小陷阱，具体内容见原文。</p>

<h6>2.2.1 URI模板</h6>

<p>如果想要访问URL中的某个部分，那么就可以在@RequestMapping的路径变量中使用URL模板。</p>

<p>在函数中使用@PathVariable注解时，意味着函数的这个变量需要绑定到URI模板变量的某个部分。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping(value="/owners/__{ownerId}__", method=RequestMethod.GET)
</span><span class='line'>public String findOwner(@PathVariable String ownerId, Model model) {
</span><span class='line'>  Owner owner = ownerService.findOwner(ownerId);  
</span><span class='line'>  model.addAttribute("owner", owner);  
</span><span class='line'>  return "displayOwner"; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果代码编译是在启用debugging模式下进行的，那么路径中的ownerId的值会被设置到函数变量ownerId中；如果没有启用debugging模式，那么必须给函数变量指定它要映射到的路径变量的名称，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
</span><span class='line'>public String findOwner(__@PathVariable("ownerId")__ String ownerId, Model model) {
</span><span class='line'>  // implementation omitted
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，在没有启用debugging模式的时候，路径中的变量是可以和函数声明中的变量按名称来进行匹对，进而赋值的；在没有启用debugging模式的时候，必须要指定与函数签名中的变量进行匹对的路径中的变量的名称。所以在没有启用debugging的时候，下面的写法也是而已的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
</span><span class='line'>public String findOwner(@PathVariable("ownerId") String __theOwner__, Model model) {
</span><span class='line'>  // implementation omitted
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然也可以指定多个路径变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping(value="__/owners/{ownerId}/pets/{petId}__", method=RequestMethod.GET)
</span><span class='line'>public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
</span><span class='line'>  Owner owner = ownerService.findOwner(ownderId);  
</span><span class='line'>  Pet pet = owner.getPet(petId);  
</span><span class='line'>  model.addAttribute("pet", pet);  
</span><span class='line'>  return "displayPet"; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面的实例演示了相对路径的用法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/owners/{ownerId}")
</span><span class='line'>public class RelativePathUriTemplateController {
</span><span class='line'>
</span><span class='line'>  @RequestMapping("/pets/{petId}")
</span><span class='line'>  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {    
</span><span class='line'>    // implementation omitted
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：@PathVariable中声明的变量可以是任意类型的，Spring会进行自动的类型转换，如果转换失败的话，会抛出TypeMismatchException异常。我们也可以通过定制data binder来定制这个转换的过程，具体见后面。</strong></p>

<h6>2.2.2 @RequestMapping的更多选项</h6>

<p>除了URI模板之外，@RequestMapping同样支持正则，比如<code>/myPath/*.do</code>，URI路径和正则的组合也是支持的（<code>/owners/*/pets/{petId}</code>）。</p>

<p>如果没有严格匹配的方法来处理请求，那么处理方法的名称用于缩小范围。如果有多个这样的方法，那么就会在这些方法里面进行选择。</p>

<p>可以通过类似于<code>myParam=myValue</code>的参数条件来缩小路径匹配的范围。比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/owners/{ownerId}")
</span><span class='line'>public class RelativePathUriTemplateController {
</span><span class='line'>
</span><span class='line'>  @RequestMapping(value = "/pets/{petId}", __params="myParam=myValue"__)
</span><span class='line'>  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {    
</span><span class='line'>    // implementation omitted
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>“myParam”这种形式的表达式也是允许的，意思是参数myParam存在于请求路径中，同样的，“！myParam”的意思是参数myParam不存在与请求路径中。</p>

<p>相似的，也可以通过比较header的信息来缩小路径匹配的范围：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/owners/{ownerId}")
</span><span class='line'>public class RelativePathUriTemplateController {
</span><span class='line'>
</span><span class='line'>@RequestMapping(value = "/pets", method = RequestMethod.POST, __headers="content-type=text/*"__)
</span><span class='line'>  public void addPet(Pet pet, @PathVariable String ownerId) {    
</span><span class='line'>    // implementation omitted
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>2.2.3 处理方法支持的参数和返回值类型</h6>

<p>被@RequestMapping注解的处理方法可以有非常灵活的签名，他们中的很多都可以以任意的顺序所使用。</p>

<ul>
<li>Request和Response对象（Servlet API）：选择任意指定的request或者response类型，比如ServletRequest和HttpServletRequest；</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring ioc]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/27/spring-ioc/"/>
    <updated>2013-05-27T00:26:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/27/spring-ioc</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS跨域(Get)]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/25/js-cross-domain/"/>
    <updated>2013-05-25T00:14:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/25/js-cross-domain</id>
    <content type="html"><![CDATA[<h4>什么是跨域</h4>

<p>在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。</p>

<p>所谓同源是指，<strong>域名，协议，端口</strong>相同。</p>

<!-- more -->


<h4>JSONP解决跨域的问题</h4>

<p>JSON(JavaScript Object Notation), JSONP(JSON with Padding)</p>

<p>在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的。</p>

<p><strong>但img、iframe、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据。利用script标签的开放策略，我们可以实现跨域请求数据，当然，也需要服务端的配合。</strong></p>

<p>当我们正常地请求一个JSON数据的时候，服务端返回的是一串JSON类型的数据，而我们使用JSONP模式来请求数据的时候，服务端返回的是一段可执行的JavaScript代码。</p>

<h5>请求JSON数据</h5>

<p>URL     http://lifeblog.bd17kaka.net/json?id=123</p>

<p>返回数据    {&#8220;id&#8221;: 123, &#8220;name&#8221; : &#8220;json&#8221;}</p>

<h5>请求JSONP数据</h5>

<p>URL     http://lifeblog.bd17kaka.net/json?id=123&amp;callback=cb</p>

<p>返回数据    cb({&#8220;id&#8221;: 123, &#8220;name&#8221; : &#8220;json&#8221;});</p>

<p>上述返回数据包含一段可以执行的代码，客户端应该有cb这个函数。当然，更好返回值写法应该是：
try{cb({&#8220;id&#8221;: 123, &#8220;name&#8221; : &#8220;json&#8221;});}catch(e){}</p>

<h4>解决方案</h4>

<p>动态创建一个script标签，src地址是要访问的地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;script type="text/javascript" src="http://lifeblog.bd17kaka.net/json?id=123&callback=cb"&gt;&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>服务器接收到请求，返回如下格式的字符串，包含一段可执行的JS代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try{cb({"id": 123, "name" : "json"});}catch(e){}</span></code></pre></td></tr></table></div></figure>


<p>客户端创建一个cb函数，接收参数，进行相应的处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function cb(data) {alert(data);}</span></code></pre></td></tr></table></div></figure>


<h4>JQUERY解决方案</h4>

<h5>在AJAX中，将dataType设置为“jsonp”</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$.ajax({
</span><span class='line'>        dataType: 'jsonp',
</span><span class='line'>        url: 'http://lifeblog.bd17kaka.net/json?id=123',
</span><span class='line'>        success: function(data){
</span><span class='line'>          
</span><span class='line'>        }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h5>使用getJson方法，在地址中加上callback参数，客户端需要有这个callback的实现</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$.getJSON('http://lifeblog.bd17kaka.net/json?id=123&callback=cb', function(data){
</span><span class='line'>  cb(data);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h5>使用getScript方法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function foo(data){
</span><span class='line'>        //处理data数据
</span><span class='line'>}
</span><span class='line'>$.getScript('http://lifeblog.bd17kaka.net/json?id=123&callback=cb');</span></code></pre></td></tr></table></div></figure>


<h4>参考</h4>

<ul>
<li><a href="http://www.clanfei.com/2012/08/1637.html">jQuery中利用JSONP解决AJAX跨域问题</a></li>
<li><a href="http://www.cnblogs.com/chopper/archive/2012/03/24/2403945.html">深入浅出JSONP&#8211;解决ajax跨域问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[call java in nodejs]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/02/call-java-in-nodejs/"/>
    <updated>2013-05-02T22:43:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/02/call-java-in-nodejs</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux上常见DNS记录查询]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/16/dns-lookup-cmds-in-linux/"/>
    <updated>2013-04-16T09:40:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/16/dns-lookup-cmds-in-linux</id>
    <content type="html"><![CDATA[<p>首先介绍一个查询DNS记录很好的网站：<a href="http://mxtoolbox.com/SuperTool.aspx">MXToolBox</a></p>

<p>查询DKIM记录：dig TXT + short mail._domainkey.domain.com</p>

<p>查询SPF记录：dig TXT +short domain.com</p>

<p>查询MX记录：dig MX domain.com</p>

<p>查询A记录：dig A domain.com</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是邮件信誉度]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/08/what-is-email-reputation/"/>
    <updated>2013-04-08T22:22:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/08/what-is-email-reputation</id>
    <content type="html"><![CDATA[<h5>什么是邮件信誉度</h5>

<p>邮件信誉度就想信用卡积分一样，你有一个初始值，需要一段时间慢慢积攒成一个好的信誉度，也有可能一瞬间摧毁你的信誉度。所以，即使你有一个好的信誉度，也不意味着你可以做任意的事情。</p>

<h5>什么会影响邮件信誉度</h5>

<p>以下这些因素经常被反垃圾邮件工具用来作为标准：</p>

<ul>
<li>用户report spam的数量</li>
<li>发往不存在邮箱地址的邮件比例</li>
<li>命中spam trap的频率</li>
<li>邮件发出去多长时间，邮件接收者就点击取消订阅</li>
<li>容量，邮件发送频率已经邮件发送量</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux crontab]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/08/linux-crontab/"/>
    <updated>2013-04-08T22:21:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/08/linux-crontab</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[how to improve email reputation]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/07/how-to-improve-email-reputation/"/>
    <updated>2013-04-07T22:05:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/07/how-to-improve-email-reputation</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[邮件验证]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/07/email-authentation/"/>
    <updated>2013-04-07T22:04:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/07/email-authentation</id>
    <content type="html"><![CDATA[<p>要想让邮件准确的到达目标客户的收件箱，最好的方法就是满足ISPs的需要，其中对邮件信息进行验证是很重要的部分。</p>

<!-- more -->


<h4>什么是邮件验证</h4>

<p>主要有三个部分的邮件验证：</p>

<h5>IP反解</h5>

<p>对于设置了反向解析的IP认为是固定IP，可以追查到使用人。如果发了大量垃圾邮件可以通知IP管理单位协助封停。而对于没有反向解的IP被认为是动态IP，或不可信IP，被大量用来发送垃圾邮件。</p>

<h5>SenderID / SPF</h5>

<p>SenderID和SPF是基于IP的验证。在这种验证机制中，Sender指定哪些IP是属于一个指定的域名的（Sender的域名）。</p>

<p>当一个Sender请求一个到ISP得连接的时候，这个ISP使用这个技术，到 DNS上查询这个IP是否在这个域名的SPF记录下面，也就是这个IP有没有使用这个域名发送邮件的权限。</p>

<p>Gmail和Yahoo会验证SPF，Hotmail会验证SenderID。
SPF和SenderID的区别是获取Sender的算法不同。</p>

<h5>Domain Keys / DKIM</h5>

<p>Domain Keys/DKIM是加密的邮件内容加密算法。在这种机制中，sender在邮件原文中添加一个DKIM-Signature字段，用于ISPs对接收到得内容进行验证。</p>

<p>ISP获取发送域名（DKIM-Signature中的h字段）和DKIM-Signature数字签名，执行一次DNS查询获取到公钥，然后进行邮件正文内容验证。</p>

<p>Gmail和Hotmail验证DKIM，yahoo验证Domain keys</p>

<h4>是否一定需要进行验证？</h4>

<p>如果你的消息没有进行任何验证，那么ISPs<strong>可能会</strong>拒绝连接。所以使用所有的验证机制是比较好的。</p>

<h4>使用了验证机制后，邮件就不会被拒绝了吗？</h4>

<p>ISPs主要还是使用你的IP和域名的<strong>信誉度</strong>来决定是否接受或者拒绝你的邮件，或者将邮件发送到收件箱还是垃圾箱。</p>

<p>验证机制可以帮助ISP来验证你的身份或者邮件内容，但是他并不能提高你的信誉度。</p>

<p>换句话说，验证不一定能提高你的邮件到达率。但是如果没有验证的话，即使你有一个很好的信誉度，也会影响到邮件的到达率。</p>

<h4>信誉度和验证</h4>

<p>上述的三种验证，只能验证IP是否是固定IP，IP是否有权限以声明为某域名发送邮件，邮件内容是否被纂改，但是不能确保你发送的邮件不是垃圾邮件等等。<strong>所以IP和域名的信誉度才是邮件到达率更关键的因素。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关注From Name信誉度]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/05/email-from-name-reputation/"/>
    <updated>2013-04-05T20:44:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/05/email-from-name-reputation</id>
    <content type="html"><![CDATA[<p>下面是对<a href="http://www.adstation.com/a-new-years-resolution-monitor-your-from-name-from-address-reputation/">A New Year’s Resolution: Monitor Your “From Name” (From Address) Reputation</a>的翻译和总结，是关于“关注From Name信誉度”的一篇文章。</p>

<!-- more -->


<p>在去年12月中旬，发现Yahoo开始将一些在白名单中的Sender发送的邮件，发送到垃圾箱中。通过分析了解到，Yahoo的这个策略几乎会影响使用多个“From Name”发送邮件的发送者。</p>

<ul>
<li>注意这里的“From Name”和“Friendly From Name”的区别：以发送地址“reputation &lt; bd17kaka@gmail.com > ”为例，“Friendly From Name”指的是“reputation”，“From Name”指的是bd17kaka。而Yahoo的这个变化时针对“From Name”的。</li>
</ul>


<h5>Yahoo做了什么改变</h5>

<p>Yahoo的信誉度规则发生了改变，从去年12月开始，Yahoo使用“From Name”+“Domain Name”+“IP”的组合来确定信誉度：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“From Name + Domain Name + IP”</span></code></pre></td></tr></table></div></figure>


<p>同时也确定“Friendly From Name”和信誉度以及邮件是进入收件箱还是垃圾箱没有什么关系。</p>

<h5>影响了谁，谁需要改变</h5>

<ul>
<li>最近改变了From Name，并且没有为新的From Name建立信誉度；</li>
<li>使用多个From Name，并且任何一个From Name组合的信誉度都不满足Yahoo的需求；</li>
</ul>


<p>在以前，如果某一域名下的所有From Name的所有组合的平均信誉度是可以接受的话，邮件就会被发送到收件箱。经过这个改变之后，如果任何一个From Name的组合不是被接受的，那么这个组合发出来的邮件将不会被发送到收件箱。</p>

<p>考虑下面三个From Name：</p>

<ul>
<li>fromname_1@bd17kaka.net</li>
<li>fromname_2@bd17kaka.net</li>
<li>fromname_3@bd17kaka.net</li>
</ul>


<p>假设前两个From Name的组合满足Yahoo的要求，但是第三个FromName是不满足的，那么前两个From Name发出来的邮件会发送到收件箱，第三个From Name发出来的邮件会进入垃圾箱。</p>

<h5>如果From Name的信誉度很差，那么修改From Name会有帮助吗？</h5>

<p>直到新的From Name建立一个好的信誉度之前，修改From Name都没有什么帮助。如果你不提升你发送邮件的策略，那么新的FromName也不会有一个好的信誉度。</p>

<h5>Yahoo为什么做这个改变？</h5>

<p>发送者对于不同收件人列表，使用不同的FromName和相同的IP来发送邮件。对于建立了好的信誉度的部分，会给予奖励，相反会给予惩罚。</p>

<p>在以前，忽略FromName不管，如果一个发送者的平均信誉度满足Yahoo的要求，那么它是可以被接受的。可是现在不再是这样的了。</p>

<h5>原文链接</h5>

<p><a href="http://www.adstation.com/a-new-years-resolution-monitor-your-from-name-from-address-reputation/">Monitor Your “From Name” (From Address) Reputation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/02/mail-dkim-spf-ptr/"/>
    <updated>2013-04-02T23:36:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/02/mail-dkim-spf-ptr</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[email_user_reputation]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/02/email-user-reputation/"/>
    <updated>2013-04-02T23:27:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/02/email-user-reputation</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java_jti]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/02/java-jti/"/>
    <updated>2013-04-02T23:21:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/02/java-jti</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java_aot]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/02/java-aot/"/>
    <updated>2013-04-02T23:20:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/02/java-aot</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[email_basic_concept]]></title>
    <link href="http://zhangdian.github.com/blog/2013/04/02/email-basic-concept/"/>
    <updated>2013-04-02T23:20:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/04/02/email-basic-concept</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java_gc]]></title>
    <link href="http://zhangdian.github.com/blog/2013/03/27/java-gc/"/>
    <updated>2013-03-27T23:43:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/03/27/java-gc</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMQ]]></title>
    <link href="http://zhangdian.github.com/blog/2013/03/27/rabbitmq/"/>
    <updated>2013-03-27T17:02:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/03/27/rabbitmq</id>
    <content type="html"><![CDATA[<h3>RabbitMQ</h3>

<p>RabbitMQ是一个消息代理，它接收和转发消息。它有六种模式，下面介绍其中的四种模式。</p>

<!-- more -->


<h4>1. 最简单的模式</h4>

<p><img src="https://dl.dropbox.com/u/99113526/blog.bd17kaka.net/rabbitmq-1.png"></p>

<h5>1.1 角色</h5>

<ul>
<li>生产者(Producing)除了发送消息之外，什么也不做，用“P”表示；</li>
<li>所有消息都存储在Queue里面，所有消息都流经Queue以及我们的应用程序。Queue没有任何限制，它可以存储尽可能多的消息，本质上，它是一个无穷大(infinite)的buffer；</li>
<li>消费者(Consumer)等待接收消息，用“C”表示。</li>
</ul>


<p>这三个角色没必要在一个机器上，实际上也是这样的。</p>

<h5>1.2 生产者</h5>

<p>生产者发送消息的时候，一定要保证Queue的存在，如果它发送消息到一个不存在的Queue，RabbitMQ会丢弃掉这个消息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.queue_declare(queue='hello')</span></code></pre></td></tr></table></div></figure>


<p>RabbitMQ中，消息实际上不会直接发送到Qeueu上，而是先发送到Exchange上，不指定Exchange的话，会发送到默认的Exchange（“”，空字符串）上。</p>

<p>需要在routing_key参数中指定Queue的名称：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.basic_publish(exchange='',
</span><span class='line'>                      routing_key='hello',
</span><span class='line'>                      body='Hello World!')print " [x] Sent 'Hello World!'"</span></code></pre></td></tr></table></div></figure>


<p>退出之前，需要确保清空缓存，并且所有的消息都发送到RabbitMQ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>connection.close()</span></code></pre></td></tr></table></div></figure>


<h5>1.3 消费者</h5>

<p>首先要连接到服务器，其次，要保证Queue的存在，使用queue_declare创建Queue是幂等的（idempotent，也就是多次创建，只会有一个同一名字的Queue被创建），所以，重新声明一个Queue永远是比较好的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.queue_declare(queue='hello')</span></code></pre></td></tr></table></div></figure>


<p>RabbitMQ通过注册一个回调函数来接收消息，每次接收到一个消息的时候，都会调用回调函数。其次，需要指定消费者从指定的Queue来接收消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def callback(ch, method, properties, body):
</span><span class='line'>    print " [x] Received %r" % (body,)
</span><span class='line'>
</span><span class='line'>channel.basic_consume(callback,
</span><span class='line'>                      queue='hello',
</span><span class='line'>                      no_ack=True)</span></code></pre></td></tr></table></div></figure>


<p>为了保证正确的读取消息，要保证Queue的存在，只要我们在生产者端创建了Queue，那么就可以保证这点。</p>

<p>然后，就会进入到一个永远都不会停止的循环，只要有消息都会调用回调函数。</p>

<h4>2. One producer, multi consumer</h4>

<p><img src="https://dl.dropbox.com/u/99113526/blog.bd17kaka.net/rabbitmq-2.png"></p>

<p>这种模型用于在众多的Workers之间分发一些耗时的任务。</p>

<p>这种模型的主要思想是：避免立即执行资源密集型的任务，等待其完成。而是将任务压缩成一个消息，将其发送到queue。Worker在后台获取这些任务，然后执行它们。如果允许多个Worker，那么它们会公平的分享这些消息。</p>

<p>这个模型特别适合：在一个短的HTTP周期内完成一个很复杂任务的应用。</p>

<h5>2.1 Round-robin dispatching(轮询调度)</h5>

<p>这种模型很容易做到平衡工作调度。如果突然多了很多的消息，那么可以添加更多的Worker来解决，很容易扩展。</p>

<p>默认情况下，RabbitMQ会按顺序的，将每个消息分发给下一个consumer，平均来看，每个consumer会获得相同数目的消息。这种分发消息的模式叫做Round-robin。</p>

<h5>2.2 Message ACK</h5>

<p>当一个worker开始一个耗时的task，但是在执行了一部分的时候失败了。对于当前的RabbitMQ的代码，当一个消息被分发到worker之后，它会立即从内存中删掉。在这种情况下，如果一个worker没有正确的执行完一个消息，那么这个消息就丢失了。</p>

<p>当然，我们不希望丢失掉任何的tasks，如果执行该task的worker挂掉了，那么应该将这个task分发给其他的worker去执行。</p>

<p>为了确保一个消息永远都不会丢失，RabbitMQ引入了消息ACK的机制。当worker执行完了一个task之后，就会发送一个消息给RabbitMQ，说明某个消息已经被执行完毕了，RabbitMQ可以将这个消息删除了。</p>

<p>如果worker挂掉了，那么它就不会发送ACK了，RabbitMQ就知道某个消息没有完整的被执行，然后会重新将这个task发送给其他的worker，这就可以保证消息不会丢失。（但是，如果task执行完了，发送了ACK，由于某种原因，ACK没有成功的抵达RabbitMQ，那么这个task会被重新执行一次。）</p>

<p>在RabbitMQ中，没有消息延迟的概念，task只有在到某个worker的连接断掉之后，才会重发。即使一个task执行了很长很长的时候，也是正常的。</p>

<p>默认情况下，ACK是打开的，也是可以设置的。</p>

<p>有一种常见的错误：在worker执行完了之后，没有返回ACK，那么RabbitMQ会不断的重发消息。但是由于消息都没有返回ACK，那么RabbitMQ会不断的吃内存，将消息保存起来。对于这种情况，可以通过使用rabbitmqctl工具来查看messages_unacknowledged字段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
</span><span class='line'>Listing queues ...
</span><span class='line'>hello    0       0
</span><span class='line'>...done.</span></code></pre></td></tr></table></div></figure>


<h5>2.3 Message durability（消息持久）</h5>

<p>上一节讲到如何保证在worker挂掉的时候，不让消息丢失，但是如何保证RabbitMQ挂掉的时候，不丢失消息呢？那么消息就不能只保存在内存了，必须持久化。</p>

<p>为了保证在RabbitMQ挂掉的时候，消息不丢失，需要做两件事情：queue和messages都是持久化的。</p>

<p>首先要保证RabbitMQ不会丢失Queue，指定durable参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.queue_declare(queue='task_queue', durable=True)</span></code></pre></td></tr></table></div></figure>


<p>RabbitMQ不允许使用不同的参数来重定义已经存在的Queue，如果这么做，会返回一个error。所以在上面的代码中，如果Queue &#8220;hello&#8221;已经存在的话，这样是没有用的，必须指定另外一个Queue名称。</p>

<p>指定了 durable=True 之后，即使RabbitMQ重启，Queue也不会丢失了。</p>

<p>其次，我们需要保证将我们的message标记为持久的了，通过指定参数delivery_mode = 2：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.basic_publish(exchange='',
</span><span class='line'>                      routing_key="task_queue",
</span><span class='line'>                      body=message,
</span><span class='line'>                      properties=pika.BasicProperties(
</span><span class='line'>                         delivery_mode = 2, # make message persistent
</span><span class='line'>                      ))</span></code></pre></td></tr></table></div></figure>


<p>注意：
即使通过指定参数来保证保存message消息到disk，从而不会丢失，但是总有一个时刻：RabbitMQ刚刚接手了一个消息，但是还没有保存到disk。<strong>也就是，RabbitMQ并不能保存对每个消息执行fsync。这个持久化的保证并不强大，但是总比简单的task queue要好一点。</strong>如果需要更强大的持久化保证，只能wrap它的代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fsync：同步内存中所有已修改的文件数据到储存设备。
</span><span class='line'>[详细](http://baike.baidu.com/view/8092902.htm)</span></code></pre></td></tr></table></div></figure>


<h5>2.4 Fair dispatch（公平分发）</h5>

<p>有些时候，上面的轮训分发并不能完全按照我们想象的来工作，比如：有两个worker，所有奇数的消息都是耗时的，偶数的消息都是不耗时的，那么所有耗时的消息都会被分发到worker-1上，所有不耗时的消息都会被分发到worker-2上。但是RabbitMQ什么都不知道，只能这么简单的分发消息，而并没有考虑某个Worker上UnACK的消息的个数。</p>

<p>可以通过如下设置来解决这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.basic_qos(prefetch_count=1)</span></code></pre></td></tr></table></div></figure>


<p>这个参数告诉RabbitMQ，不要在同一时刻向同一个worker分发多余一个的消息，也就是说，在接受到之前的task的ACK之前，不要再分发消息给worker。</p>

<p><strong>当心Queue的大小：如果所有的Queue都busy，那么Queue就会不断变长，要么一直盯着，要么增加更多的worker，要么使用一些其他的策略。
</strong></p>

<h5>2.5 完整代码</h5>

<p><a href="http://www.rabbitmq.com/tutorials/tutorial-two-python.html">官方网站</a></p>

<h4>3 订阅发布</h4>

<p>在前面的模式中，每个消息只会发送到一个worker。在这里的“订阅发布”模式中，会发送一个消息给多个consumer。</p>

<h5>3.1 Exchanges</h5>

<p>在前面的部分中，只是介绍了从一个单独的Queue来接受消息，这里会介绍RabbitMQ的完整的消息模型。</p>

<p><img src="https://dl.dropbox.com/u/99113526/blog.bd17kaka.net/rabbitmq-2.png"></p>

<p>在RabbitMQ中，producer永远不会直接将消息发送给Queue，实际上Producer甚至并不知道一个消息会被发送到一个Queue上。Producer只是将消息发送到exchange上。exchange一方面接收消息，一方面将消息推送到Queue上。Exchange必须知道如何处理每个接收到的消息：附加到一个Queue上？附加到多个Queue上？还是忽略之。</p>

<p>有很多种可用的exchange：direct, topic, headers and fanout。本节，主要介绍fanout。创建一个fanout类型的exchange：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.exchange_declare(exchange='logs',
</span><span class='line'>                         type='fanout')</span></code></pre></td></tr></table></div></figure>


<p>fanout类型的exchange的作用很简单，就是将它接收到得所有消息，分发到每一个它所知道的Queue。</p>

<p>然后就可以将消息发送到“logs”这个exchange：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.basic_publish(exchange='logs',
</span><span class='line'>                      routing_key='',
</span><span class='line'>                      body=message)</span></code></pre></td></tr></table></div></figure>


<h5>3.2 临时Queue</h5>

<p>我们有时只关注当前的消息，而并不关注之前的消息，或者希望在consumer断开与RabbitMQ的连接之后，不保存Queue中的消息，那么可以使用临时Queue。要做到这点，需要两点：</p>

<ul>
<li>在server端创建一个使用随机Queue名称的channel；</li>
<li>客户端在声明Queue的时候，加上exclusive=true参数；</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(客户端)
</span><span class='line'>result = channel.queue_declare(exclusive=True)</span></code></pre></td></tr></table></div></figure>


<h5>3.3 绑定</h5>

<p>接下来，就需要绑定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(客户端)
</span><span class='line'>channel.queue_bind(exchange='logs',
</span><span class='line'>                   queue=result.method.queue)</span></code></pre></td></tr></table></div></figure>


<h4>4 Routing</h4>

<p>这一节介绍的模型可以只将所有消息的子集发送到某个指定的Queue。比如在日志系统中，可以将error消息和warning消息发送到两个不一样的Queue。</p>

<p>在bing过程中，可以指定一个routing_key参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.queue_bind(exchange=exchange_name,
</span><span class='line'>                   queue=queue_name,
</span><span class='line'>                   routing_key='black')</span></code></pre></td></tr></table></div></figure>


<p>routing_key在有的类型的exchange中是被忽视的，比如在前面的fanout模型中，是被忽略的。</p>

<h5>4.1 Direct exchange</h5>

<p><img src="https://dl.dropbox.com/u/99113526/blog.bd17kaka.net/rabbitmq-4.png"></p>

<p>在这个图中可以看到，exchange和两个Queue绑定，第一个Queue和routing_key为orange的消息绑定，第二个Queue和routing_key为black和green的Queue绑定。</p>

<p>消息根据它们的routing_key被分发到不同的Queue。</p>

<p>也可以将一个routing_key绑定到多个Queue，如果绑定到所有的Queue的话，那么这种模型和fanout exchange就是一样的了。</p>

<h5>4.2 producer分发消息</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>channel.exchange_declare(exchange='direct_logs',
</span><span class='line'>                         type='direct')
</span><span class='line'>
</span><span class='line'>channel.basic_publish(exchange='direct_logs',
</span><span class='line'>                      routing_key=severity,
</span><span class='line'>                      body=message)</span></code></pre></td></tr></table></div></figure>


<h5>4.3 consumer消费消息</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = channel.queue_declare(exclusive=True)queue_name = result.method.queue
</span><span class='line'>
</span><span class='line'>for severity in severities:
</span><span class='line'>    channel.queue_bind(exchange='direct_logs',
</span><span class='line'>                       queue=queue_name,
</span><span class='line'>                       routing_key=severity)</span></code></pre></td></tr></table></div></figure>


<p>continue&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java共享类]]></title>
    <link href="http://zhangdian.github.com/blog/2013/03/27/java-shared-class/"/>
    <updated>2013-03-27T17:02:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/03/27/java-shared-class</id>
    <content type="html"><![CDATA[<p>共享类特性是从头设计的，它是一个可以打开和关闭的选项，可以减少虚拟内存占用并改进 JVM 启动时间。因此，<strong>它非常适合多个 JVM 运行相似代码的环境或者 JVM 常常重新启动的环境。</strong></p>

<h5>1 类缓存</h5>

<p>类缓存是一个大小固定的共享内存区，它在使用它的 JVM 的生命周期之外仍然持久地存在。一个系统上可以有任意数量的共享类缓存，这只受操作系统设置的限制；<strong>但是一个 JVM 在它的生命周期中只能连接一个缓存。</strong></p>

<!-- more -->


<p>JVM 并不拥有缓存，也没有 主/从 JVM 的概念；实际上，任意数量的 JVM 都可以并行地读写缓存。在两种情况下会删除缓存：</p>

<ul>
<li>使用 JVM 实用程序显式地销毁它</li>
<li>或者操作系统重新启动时（缓存无法在操作系统重新启动时持久存在）。</li>
</ul>


<p>缓存的大小无法增长，当它被填满时，JVM 仍然可以从其中装载类，但是不能再向其中添加任何类。</p>

<h5>2 如何缓存类</h5>

<p>当 JVM 装载一个类时，它先查看需要的类是否已经在缓存中存在。如果是这样，那么它从缓存装载这个类。否则，它从文件系统装载这个类并将其写到缓存中（在 defineClass() 调用中进行这一操作）。</p>

<p>不进行共享的 JVM 采用以下类装载器查找次序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>类装载器缓存
</span><span class='line'>父类装载器
</span><span class='line'>文件系统</span></code></pre></td></tr></table></div></figure>


<p>进行共享的 JVM 采用以下次序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__类装载器缓存__
</span><span class='line'>父类装载器
</span><span class='line'>__共享缓存__
</span><span class='line'>文件系统</span></code></pre></td></tr></table></div></figure>


<h5>3 缓存类的哪些部分</h5>

<p>在 JVM 的 IBM 实现中，Java 类分成两个部分：</p>

<ul>
<li>一个称为 ROMClass 的只读部分，其中包含不可变的所有类数据；</li>
<li>一个 RAMClass 部分，其中包含可变的数据，比如静态类变量。</li>
</ul>


<p>RAMClass 指向 ROMClass 中的数据，但是这两部分是完全分开的，这意味着 ROMClass 可以十分安全地在 JVM 之间共享，甚至在同一个 JVM 中的 RAMClass 之间共享。</p>

<h5>4 共享类好处</h5>

<ul>
<li>因为大部分类数据存储在 ROMClass 中，因此可以节省虚拟内存；</li>
<li>已经填充的缓存还会显著改进 JVM 启动时间，因为每个缓存的类的一部分定义工作已经完成了，而且会从内存装载类而不是从文件系统装载；</li>
<li>填充新缓存导致的启动时间开销并不显著，因为每个类只需在定义时重新定位到缓存中；</li>
</ul>


<h5>5 如果文件系统中的类发生变化</h5>

<p>因为缓存是无限期持久存在的，文件系统更新可能会使缓存中的类失效。因此，当类装载器请求一个共享的类时，缓存代码要负责确保返回的类总是与从文件系统装载的类完全一样。当装载类时这一检查会透明地进行，所以用户可以在共享类缓存的生命周期内修改和更新任意类，系统总会装载正确的类。</p>

<p>JVM 探测文件系统更新的方法是，将时间戳值存储在缓存中并在装载每个类时比较缓存的值和实际值。如果它探测到一个 JAR 文件已经更新了，那么它不知道哪些类已经更新了，所以缓存中所有从这个 JAR 装载的类都立即被标为过时的，不能再从缓存中装载它们。当从文件系统装载这个 JAR 中的类并重新添加到缓存中时，只添加实际修改过的类；那些没有修改的类实际上没有过时。</p>
]]></content>
  </entry>
  
</feed>
