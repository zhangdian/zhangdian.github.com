<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | bd17kaka's blog]]></title>
  <link href="http://zhangdian.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://zhangdian.github.com/"/>
  <updated>2013-06-14T22:02:30+08:00</updated>
  <id>http://zhangdian.github.com/</id>
  <author>
    <name><![CDATA[bd17kaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java定时任务]]></title>
    <link href="http://zhangdian.github.com/blog/2013/06/14/java-schedule-task/"/>
    <updated>2013-06-14T21:56:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/06/14/java-schedule-task</id>
    <content type="html"><![CDATA[<h2>定时任务</h2>

<h3>关于定时任务</h3>

<p>定时任务有两种：</p>

<ul>
<li>固定延时的定时任务，即一个任务结束等待固定时间后再执行下一个；</li>
<li>固定频率的定时任务，即任务在固定时常后开始执行。</li>
</ul>


<p>前者的意思是，任务完成之后，等待固定的诗句再执行下一个；而后者的意思是在固定的时间执行任务，如果前一次任务的结束时间已经超过了下一次任务开始的时间，那么就会立即执行。</p>

<h3>定时任务实现方案</h3>

<p>Timer和ScheduledThreadPoolExecutor都可以完成定时任务的工作，也都支持上面的两种方式。</p>

<p>下面分别给出两个类的示例：</p>

<pre><code>package com.concurrent.basic;
import java.util.Timer;
import java.util.TimerTask;
public class TimerTest {
    private Timer timer = new Timer();

    // 启动计时器
    public void lanuchTimer() {
        timer.schedule(new TimerTask() {
            public void run() {
                // do sth...
            }
        }, 1000 * 3, 500);
    }

    public static void main(String[] args) throws Exception {
        TimerTest test = new TimerTest();
        test.lanuchTimer();
    }
}
</code></pre>

<p>这个例子是固定延时的任务，详细文档见<a href="http://docs.oracle.com/javase/7/docs/api/">Timer</a>，文档中，也有scheduleAtFixedRate方法来调用固定频率的任务。</p>

<pre><code>package com.concurrent.basic;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorTest {

    public ScheduledExecutorService scheduExec = Executors
            .newScheduledThreadPool(1);

    // 启动计时器
    public void lanuchTimer() {
        Runnable task = new Runnable() {
            public void run() {
                // do sth...
            }
        };
        scheduExec.scheduleWithFixedDelay(task, 1000 * 5, 1000 * 10,
                TimeUnit.MILLISECONDS);
    }

    public static void main(String[] args) throws Exception {
        ScheduledExecutorTest test = new ScheduledExecutorTest();
        test.lanuchTimer();
    }
}
</code></pre>

<p>这个例子是固定延时的任务示例，也可以调用scheduleAtFixedRate方法来启用固定频率的任务。</p>

<h3>比较</h3>

<ul>
<li>Timer对系统时钟是敏感的，而ScheduledThreadPoolExecutor不是；</li>
<li>Timer只有一个执行线程，所以如果一个线程延时太久了，会影响其他的固定延时任务。而ScheduledThreadPoolExecutor可以配置任意数量的线程，并且你可以完成控制你所创建的这些线程；</li>
<li><em>在Timer中，运行时错误会直接杀死线程，也就会导致线程挂掉，后面计划的任务也不会执行。ScheduledThreadPoolExecutor不仅可以给你catch住运行时异常，还可以对它们进行处理。抛出异常的任务会挂掉，但是其他的定时任务会继续执行。</em></li>
</ul>


<h3>相关链接</h3>

<ul>
<li><a href="http://marshal.easymorse.com/archives/3136">通过java concurrent实现定时任务</a></li>
<li><a href="http://batitan.iteye.com/blog/253483">定时任务:Java中Timer和TimerTask的使用</a></li>
<li><a href="http://stackoverflow.com/questions/409932/java-timer-vs-executorservice">Java Timer vs ExecutorService?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring WEB MVC总结]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/27/spring-web-mvc/"/>
    <updated>2013-05-27T00:26:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/27/spring-web-mvc</id>
    <content type="html"><![CDATA[<p>用了这么久的spring web，终于把官方的文档看了看，总结出来下面的文档。</p>

<!-- more -->


<h4>Spring WEB MVC的特性</h4>

<ul>
<li>角色分明：controller、validator、command object、form object、model object、DispatcherServlet、handler mapping、view resolver等等，每个角色都可以由一个专门的对象来实现；</li>
<li>框架和类似JavaBean应用类的强大而简单的配置；</li>
<li>适配性、非侵入性以及灵活性。可以任意定义controller方法的前面，对于指定的场景，可以使用@RequestParam、@RequestHeader、@PathVariable其中的一个；</li>
<li>可重用的业务代码；</li>
<li>可定制话的绑定和验证；</li>
<li>类型匹配错误作为应用层的验证错误，取代手动将传进来的String-Only对象parse and convert成为业务对象；</li>
<li>个性化handler mapping以及view resolution；</li>
<li>灵活的model解析。利用name/value Map，可以利用任意一种view技术解析model；</li>
<li>个性化的locale以及theme resolution。支持JSPs，包不包含Spring tag lib，JSTL都行；</li>
<li>等等</li>
</ul>


<h4>其他MVC实现的可插入性</h4>

<p>如果不想使用Spring web MVC，而是想在其他类似struts、WebWork的框架中使用Spring的某些特性，这也是可以的，具体的可以查看相关文档。</p>

<h4>1. DispatcherServlet类</h4>

<p>和其他的MVC框架一样，Spring web MVC也是基于<strong>请求驱动</strong>的模型，围绕一个核心的servlet，将所有的请求分发到Controllers，同时提供丰富的功能，来帮助web应用程序的开发。Spring完全集成Spring IoC容器，允许你使用Spring所拥有的任何特性。</p>

<p>下图是Spring web MVC中的请求处理流程图：</p>

<p><img src="https://dl.dropboxusercontent.com/u/99113526/blog.bd17kaka.net/spring-web-mvc.png"></p>

<p>DispatcherServlet是Servlet类的一个子类，继承自HttpServlet，它在web.xml文件中进行定义。需要通过使用URL映射，来将需要其处理的请求映射到这个Servlet。下面是一个标准的servlet配置：</p>

<p>```</p>

<!-- web.xml -->


<p><web-app></p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;example&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;example&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p></web-app>
```</p>

<p>额外的参数：contextClass、contextConfigLocation、namespace，具体解释见原文。</p>

<p>在这个例子中，所有满足表达式“*.form”的请求，都将有servlet-name为“example”的这个servlet来进行处理。</p>

<p>在Spring中，ApplicationContext实例是有作用域的。在Web MVC架构中，每一个DispatcherServlet类都有它自己的WebApplicationContext，这个WebApplicationContext继承所有已经在根部的WebApplicationContext中所定义的beans。这些beans是可以被在servlet中定义的beans所覆盖的。（不太懂，得看看Spring Ioc）</p>

<p>在DispatcherServlet初始化的时候，Spring在文件夹WEB-INF中查找文件名为[servlet-name]-servlet.xml的文件，并且创建那个文件里面定义的所有beans。将在全局作用域中，有相同名称的bean全覆盖掉。</p>

<p>考虑上面的那个web.xml定义，那么需要在WEB-INF文件夹中，创建一个名为example-servlet.xml的文件，这个里面包含所有Spring WEB MVC所拥有的beans。</p>

<p><strong>我的理解是：一个web.xml文件中可以定义多个servlet；一个servlet对应一个example-servlet.xml文件；一个example-servlet.xml文件就是一个WebApplicationContext。</strong></p>

<p>在WebApplicationContext中，包含下面这些类型的beans：</p>

<ul>
<li>controllers</li>
<li>handler mappings</li>
<li>view resolvers</li>
<li>locale resolvers</li>
<li>theme resolver</li>
<li>multipart file resolver</li>
<li>handler exception resolvers</li>
</ul>


<p>当有一个请求到来的时候，DispatcherServlet是按照以下的顺序来处理这个请求的：</p>

<ul>
<li>搜索WebApplicationContext，并且将其作为一个attribute绑定到request中，这样，在这个过程中，controller和其他的元素都可以使用。默认情况下，它被绑定在DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE里面；</li>
<li>locale resolver绑定到request中，这样，其他的元素可以解析并使用locale（呈现view、准备数据等等）。如果你不需要locale resolving，那么就不需要他它；</li>
<li>theme resolver绑定到request中，允许views等元素决定使用哪个theme。如果不需要themes，可以忽略它；</li>
<li>如果指定了一个multipart file resolver，那么这个请求就被看做multipart。如果找到了multipart，就会将这个请求包装成一个MultipartHttpServletRequest，再由其它元素进行进一步的处理；</li>
<li>搜索一个合适的handler。如果找到了，那个和这个handler相关的执行链（preprocessors, postprocessors, and controllers）会被执行，以准备model以及呈现；</li>
<li>如果返回了一个model，那么会呈现一个view；如果没有model返回，那么不会呈现任何view，因为请求以及被执行完毕了。</li>
</ul>


<p>在WebApplicationContext中声明的Handler exception resolvers对象，接收在请求处理过程中产生的所有错误。用这些exception resolvers可以使对于不同的exception定义个性化的处理办法。</p>

<h4>2. Controllers</h4>

<p>controllers获取用户的输入，并且在处理之后，将其转换为model，进而转换为view，展现给用户。Spring提供的controller是非常抽象化的，可以定义各种各样、大量的controllers。</p>

<p>Spring2.5引入基于注解的编程模型，可以使用诸如@RequestMapping、@RequestParam、@ModelAttribute等注解。它同时支持Servlet MVC和Potlet MVC。这种情况下，不需要事先指定的基类或者指定的接口。下面是一个简单的例子：</p>

<p>```
@Controller
public class HelloWorldController {</p>

<pre><code>@RequestMapping("/helloWorld")
public ModelAndView helloWorld() {
    ModelAndView mav = new ModelAndView();
    mav.setViewName("helloWorld");
    mav.addObject("message", "Hello World!");
    return mav;
}
</code></pre>

<p>}</p>

<p>```</p>

<h5>2.1 使用@controller定义一个controller</h5>

<p>@controller标签定义一个执行controller功能的类，在Spring里面，不需要继承任何的controller基类，或者调用ServletAPI，不过，如果有需要的话，也可以调用Servlet指定的特性。</p>

<p>@controller作为被注解的类的签名，标示这个类的角色。Dispatcher类扫描以@controller做注解的类，然后寻找以@RequestMapping做注解的方法。</p>

<p>我们可以严格的对controller类使用@controller注解，但是@controller标签页支持自动搜索，依赖于Spring支持在classpath中自动搜索组件类，以及为他们完成自动注册的bean的定义。</p>

<p>只需要将扫描组件添加到配置中，即可启用自动扫描这样的注解controller的功能：</p>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:p="http://www.springframework.org/schema/p" 
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="
    http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

&lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/&gt;

// ...
</code></pre>

<p></beans>
```</p>

<h5>2.2 利用@RequestMapping来匹配请求</h5>

<p>我们可以用类似于“/handler”的注解来匹配整个类，也可以只匹配某个函数。比如，对于一个指定的HTTP请求（GET/POST）或者一个HTTP请求参数，我们经常用一个<strong>类级别</strong>的注解来将一个指定的请求映射到一个表单controller，然后使用一个额外的<strong>方法级别</strong>的注解来缩小范围。下面是一个例子：</p>

<p>```
@Controller
@RequestMapping("/handler")
public class AppointmentsController {</p>

<pre><code>private final AppointmentBook appointmentBook;

@Autowired
public AppointmentsController(AppointmentBook appointmentBook) {
    this.appointmentBook = appointmentBook;
}

@RequestMapping(method = RequestMethod.GET)
public Map&lt;String, Appointment&gt; get() {
    return appointmentBook.getAppointmentsForToday();
}

@RequestMapping(value="/{day}", method = RequestMethod.GET)
public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) {
    return appointmentBook.getAppointmentsForDay(day);
}

@RequestMapping(value="/new", method = RequestMethod.GET)
public AppointmentForm getNewForm() {
    return new AppointmentForm();
}

@RequestMapping(method = RequestMethod.POST)
public String add(@Valid AppointmentForm appointment, BindingResult result) {
    if (result.hasErrors()) {
        return "appointments/new";
    }
    appointmentBook.addAppointment(appointment);
    return "redirect:/appointments";
}
</code></pre>

<p>}
```</p>

<p>类级别的@RequestMapping注解并不是必须的，没有它的话，所有路径都是绝对路径，而不是相对路径。</p>

<p>这里有一个当使用proxy时，关于@controller注解类的小陷阱，具体内容见原文。</p>

<h6>2.2.1 URI模板</h6>

<p>如果想要访问URL中的某个部分，那么就可以在@RequestMapping的路径变量中使用URL模板。</p>

<p>在函数中使用@PathVariable注解时，意味着函数的这个变量需要绑定到URI模板变量的某个部分。</p>

<p>例如：</p>

<p><code>
@RequestMapping(value="/owners/__{ownerId}__", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
  Owner owner = ownerService.findOwner(ownerId);  
  model.addAttribute("owner", owner);  
  return "displayOwner";
}
</code></p>

<p>如果代码编译是在启用debugging模式下进行的，那么路径中的ownerId的值会被设置到函数变量ownerId中；如果没有启用debugging模式，那么必须给函数变量指定它要映射到的路径变量的名称，例如：</p>

<p>```
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(<strong>@PathVariable("ownerId")</strong> String ownerId, Model model) {
  // implementation omitted
}</p>

<p>```</p>

<p>也就是说，在没有启用debugging模式的时候，路径中的变量是可以和函数声明中的变量按名称来进行匹对，进而赋值的；在没有启用debugging模式的时候，必须要指定与函数签名中的变量进行匹对的路径中的变量的名称。所以在没有启用debugging的时候，下面的写法也是而已的：</p>

<p><code>
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String __theOwner__, Model model) {
  // implementation omitted
}
</code></p>

<p>当然也可以指定多个路径变量：</p>

<p><code>
@RequestMapping(value="__/owners/{ownerId}/pets/{petId}__", method=RequestMethod.GET)
public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
  Owner owner = ownerService.findOwner(ownderId);  
  Pet pet = owner.getPet(petId);  
  model.addAttribute("pet", pet);  
  return "displayPet";
}
</code></p>

<p>下面的实例演示了相对路径的用法：</p>

<p>```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {</p>

<p>  @RequestMapping("/pets/{petId}")
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {</p>

<pre><code>// implementation omitted
</code></pre>

<p>  }
}</p>

<p>```</p>

<p><strong>注意：@PathVariable中声明的变量可以是任意类型的，Spring会进行自动的类型转换，如果转换失败的话，会抛出TypeMismatchException异常。我们也可以通过定制data binder来定制这个转换的过程，具体见后面。</strong></p>

<h6>2.2.2 @RequestMapping的更多选项</h6>

<p>除了URI模板之外，@RequestMapping同样支持正则，比如<code>/myPath/*.do</code>，URI路径和正则的组合也是支持的（<code>/owners/*/pets/{petId}</code>）。</p>

<p>如果没有严格匹配的方法来处理请求，那么处理方法的名称用于缩小范围。如果有多个这样的方法，那么就会在这些方法里面进行选择。</p>

<p>可以通过类似于<code>myParam=myValue</code>的参数条件来缩小路径匹配的范围。比如：</p>

<p>```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {</p>

<p>  @RequestMapping(value = "/pets/{petId}", <strong>params="myParam=myValue"</strong>)
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {</p>

<pre><code>// implementation omitted
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>“myParam”这种形式的表达式也是允许的，意思是参数myParam存在于请求路径中，同样的，“！myParam”的意思是参数myParam不存在与请求路径中。</p>

<p>相似的，也可以通过比较header的信息来缩小路径匹配的范围：</p>

<p>```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {</p>

<p>@RequestMapping(value = "/pets", method = RequestMethod.POST, <strong>headers="content-type=text/*"</strong>)
  public void addPet(Pet pet, @PathVariable String ownerId) {</p>

<pre><code>// implementation omitted
</code></pre>

<p>  }
}
```</p>

<h6>2.2.3 处理方法支持的参数和返回值类型</h6>

<p>被@RequestMapping注解的处理方法可以有非常灵活的签名，他们中的很多都可以以任意的顺序所使用。</p>

<ul>
<li>Request和Response对象（Servlet API）：选择任意指定的request或者response类型，比如ServletRequest和HttpServletRequest；</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java共享类]]></title>
    <link href="http://zhangdian.github.com/blog/2013/03/27/java-shared-class/"/>
    <updated>2013-03-27T17:02:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/03/27/java-shared-class</id>
    <content type="html"><![CDATA[<p>共享类特性是从头设计的，它是一个可以打开和关闭的选项，可以减少虚拟内存占用并改进 JVM 启动时间。因此，<strong>它非常适合多个 JVM 运行相似代码的环境或者 JVM 常常重新启动的环境。</strong></p>

<h5>1 类缓存</h5>

<p>类缓存是一个大小固定的共享内存区，它在使用它的 JVM 的生命周期之外仍然持久地存在。一个系统上可以有任意数量的共享类缓存，这只受操作系统设置的限制；<strong>但是一个 JVM 在它的生命周期中只能连接一个缓存。</strong></p>

<!-- more -->


<p>JVM 并不拥有缓存，也没有 主/从 JVM 的概念；实际上，任意数量的 JVM 都可以并行地读写缓存。在两种情况下会删除缓存：</p>

<ul>
<li>使用 JVM 实用程序显式地销毁它</li>
<li>或者操作系统重新启动时（缓存无法在操作系统重新启动时持久存在）。</li>
</ul>


<p>缓存的大小无法增长，当它被填满时，JVM 仍然可以从其中装载类，但是不能再向其中添加任何类。</p>

<h5>2 如何缓存类</h5>

<p>当 JVM 装载一个类时，它先查看需要的类是否已经在缓存中存在。如果是这样，那么它从缓存装载这个类。否则，它从文件系统装载这个类并将其写到缓存中（在 defineClass() 调用中进行这一操作）。</p>

<p>不进行共享的 JVM 采用以下类装载器查找次序：</p>

<p><code>
类装载器缓存
父类装载器
文件系统
</code></p>

<p>进行共享的 JVM 采用以下次序：</p>

<p><code>
__类装载器缓存__
父类装载器
__共享缓存__
文件系统
</code></p>

<h5>3 缓存类的哪些部分</h5>

<p>在 JVM 的 IBM 实现中，Java 类分成两个部分：</p>

<ul>
<li>一个称为 ROMClass 的只读部分，其中包含不可变的所有类数据；</li>
<li>一个 RAMClass 部分，其中包含可变的数据，比如静态类变量。</li>
</ul>


<p>RAMClass 指向 ROMClass 中的数据，但是这两部分是完全分开的，这意味着 ROMClass 可以十分安全地在 JVM 之间共享，甚至在同一个 JVM 中的 RAMClass 之间共享。</p>

<h5>4 共享类好处</h5>

<ul>
<li>因为大部分类数据存储在 ROMClass 中，因此可以节省虚拟内存；</li>
<li>已经填充的缓存还会显著改进 JVM 启动时间，因为每个缓存的类的一部分定义工作已经完成了，而且会从内存装载类而不是从文件系统装载；</li>
<li>填充新缓存导致的启动时间开销并不显著，因为每个类只需在定义时重新定位到缓存中；</li>
</ul>


<h5>5 如果文件系统中的类发生变化</h5>

<p>因为缓存是无限期持久存在的，文件系统更新可能会使缓存中的类失效。因此，当类装载器请求一个共享的类时，缓存代码要负责确保返回的类总是与从文件系统装载的类完全一样。当装载类时这一检查会透明地进行，所以用户可以在共享类缓存的生命周期内修改和更新任意类，系统总会装载正确的类。</p>

<p>JVM 探测文件系统更新的方法是，将时间戳值存储在缓存中并在装载每个类时比较缓存的值和实际值。如果它探测到一个 JAR 文件已经更新了，那么它不知道哪些类已经更新了，所以缓存中所有从这个 JAR 装载的类都立即被标为过时的，不能再从缓存中装载它们。当从文件系统装载这个 JAR 中的类并重新添加到缓存中时，只添加实际修改过的类；那些没有修改的类实际上没有过时。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java类加载器]]></title>
    <link href="http://zhangdian.github.com/blog/2013/03/27/java-class-loader/"/>
    <updated>2013-03-27T13:37:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/03/27/java-class-loader</id>
    <content type="html"><![CDATA[<h4>1 类加载器基本概念</h4>

<p>一般来说，Java 应用的开发人员不需要直接同类加载器进行交互。Java 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，<strong>就很容易花大量的时间去调试 ClassNotFoundException和 NoClassDefFoundError等异常</strong>。</p>

<!-- more -->


<p>一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>

<h4>2 java.lang.ClassLoader</h4>

<p>基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。</p>

<p>除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。</p>

<h5>2.1 ClassLoader中与加载类相关的方法</h5>

<p>getParent()返回该类加载器的父类加载器。
loadClass(String name)加载名称为 name的类，返回的结果是 java.lang.Class类的实例。
findClass(String name)查找名称为 name的类，返回的结果是 java.lang.Class类的实例。
findLoadedClass(String name)查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。
defineClass(String name, byte[] b, int off, int len)把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。
resolveClass(Class&lt;?> c)链接指定的 Java 类。</p>

<h5>2.2 类加载器的树状组织结构</h5>

<p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。</p>

<h6>2.2.1 系统提供</h6>

<ul>
<li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</li>
<li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：<strong>它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。</strong>一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
</ul>


<h6>2.2.2自定义</h6>

<p>开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</p>

<h5>2.3 相互关系</h5>

<p>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；<strong>对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。</strong>类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。</p>

<h4>3 类加载器的代理模式</h4>

<p><strong>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</strong></p>

<p>在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>

<p>比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。</p>

<p>```
测试 Java 类是否相同
public void testClassIdentity() {</p>

<pre><code>String classDataRootPath = "C:\\workspace\\Classloader\\classData"; 
FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); 
FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); 
String className = "com.example.Sample";    
try { 
    Class&lt;?&gt; class1 = fscl1.loadClass(className); 
    Object obj1 = class1.newInstance(); 
    Class&lt;?&gt; class2 = fscl2.loadClass(className); 
    Object obj2 = class2.newInstance(); 
    Method setSampleMethod = class1.getMethod("setSample", java.lang.Object.class); 
    setSampleMethod.invoke(obj1, obj2); 
} catch (Exception e) { 
    e.printStackTrace(); 
} 
</code></pre>

<p> }
```</p>

<p>上述代码使用了类 FileSystemClassLoader的两个不同实例来分别加载类 com.example.Sample，得到了两个不同的 java.lang.Class的实例，接着通过 newInstance()方法分别生成了两个类的对象 obj1和 obj2，最后通过 Java 的反射 API 在对象 obj1上调用方法 setSample，试图把对象 obj2赋值给 obj1内部的 instance对象。</p>

<p><strong>虽然两个对象 obj1和 obj2的类的名字相同，但是这两个类是由不同的类加载器实例来加载的，因此不被 Java 虚拟机认为是相同的。</strong></p>

<p>了解了这一点之后，就可以理解代理模式的设计动机了。<strong>代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。</strong></p>

<p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</p>

<h4>4 类加载过程</h4>

<p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。</p>

<p>真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。<strong>前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。</strong></p>

<p>在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。<strong>两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。</strong></p>

<p>类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，<strong>对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。</strong></p>

<h4>5 线程上下文加载器</h4>

<p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。</p>

<p>如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p>

<p>前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。</p>

<p>问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。</p>

<p><strong>线程上下文类加载器正好解决了这个问题。</strong>如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>

<h4>6 类加载器和Web容器</h4>

<p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。</p>

<p>以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。</p>

<p>这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p>

<p>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>

<ul>
<li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li>
<li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li>
<li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li>
</ul>


<h4>7 相关链接</h4>

<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/">Java 类加载器</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java spring的一些best practice]]></title>
    <link href="http://zhangdian.github.com/blog/2012/12/11/java-spring-some-best-practices/"/>
    <updated>2012-12-11T15:06:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2012/12/11/java-spring-some-best-practices</id>
    <content type="html"><![CDATA[<p>一些没写过java，现在一直主要写java，刚才向公司的java大牛请教了一些关于java spring的一些观点，现在总结如下，作为自己的一些best practice。</p>

<!-- more -->


<h4>1. 异常处理</h4>

<h5>1.1 什么是异常</h5>

<p>异常分为两种，一种是checked异常，比如IOException、SQLException，一种是unchecked异常。这两种Exception的区别主要是CheckedException需要用try...catch...显示的捕获，而UncheckedException不需要捕获。通常UncheckedException又叫做RuntimeException。</p>

<ul>
<li>我们常见的RuntimeExcepiton有IllegalArgumentException、IllegalStateException、NullPointerException、IndexOutOfBoundsException等等。</li>
<li>对于那些CheckedException就不胜枚举了，我们在编写程序过程中try...catch...捕捉的异常都是CheckedException。io包中的IOException及其子类，这些都是CheckedException。</li>
</ul>


<h5>1.2 异常best practice</h5>

<ul>
<li>如果逻辑比较核心的话，那么就创建一个专门的异常，继承runtimeexception，在这个异常中需要记录能够标示这个异常的一些必要的信息，比如用户id以及基本信息等，来替代日志；</li>
<li>如果逻辑不是太核心的话，创建通用的异常类，同样继承runtimeexception，在这个异常里记录一些常用的信息；</li>
</ul>


<p>总之，我们自己创建的异常都是继承自runtimeexception的。定义特殊的类是为了记录特殊的信息，而如果没有特殊的信息，那么就使用通用的异常类就行。</p>

<h4>2. spring框架内service和dao调用</h4>

<ul>
<li>service和dao之间，service和service之间的调用其实没有什么限制，都是可以调用的；</li>
<li>一般在一个service函数中，通常是调用dao来完成这个函数的功能；</li>
<li>如果另外一个service中的一个函数，完成了我们现在要完成的一个业务，也可以直接去调用哪个函数即可，而不是去调用dao，然后把那个函数的逻辑重新走一遍，这样做的目的就是省事方便。</li>
</ul>

]]></content>
  </entry>
  
</feed>
