<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | bd17kaka's blog]]></title>
  <link href="http://zhangdian.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://zhangdian.github.com/"/>
  <updated>2013-06-25T21:37:31+08:00</updated>
  <id>http://zhangdian.github.com/</id>
  <author>
    <name><![CDATA[bd17kaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JSP页面刷新]]></title>
    <link href="http://zhangdian.github.com/blog/2013/06/25/html-page-refresh/"/>
    <updated>2013-06-25T21:33:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/06/25/html-page-refresh</id>
    <content type="html"><![CDATA[<h2>JSP页面刷新</h2>

<p>下面总结JSP页面中的三种刷新方法：</p>

<h3>在html中设置</h3>

<p>在</p>

<pre><code>&lt;title&gt;bd17kaka&lt;/title&gt;
</code></pre>

<p>之後加入下面这一行即可：</p>

<pre><code>&lt;META HTTP-EQUIV="Refresh" content="10"&gt;
</code></pre>

<p>意思是每10秒钟刷新一次页面。</p>

<h3>在JSP页面中设置</h3>

<p>加入</p>

<pre><code>&lt;% response.setHeader("refresh","1"); %&gt;
</code></pre>

<p>即可，意思是每一秒钟刷新一次。</p>

<p>也可以这样，使页面跳转到另外一个页面：</p>

<pre><code>&lt;%  
    response.setHeader("refresh","30;URL=http://www.sina.com");  
%&gt;
</code></pre>

<h3>使用JS</h3>

<p>加入如下JS代码：</p>

<pre><code>&lt;script language="javascript"&gt;
    setTimeout("self.location.reload();",1000);
&lt;script&gt;
</code></pre>

<p>意思是每一秒钟刷新一次。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA中的浅拷贝和深拷贝]]></title>
    <link href="http://zhangdian.github.com/blog/2013/06/25/java-deep-copy/"/>
    <updated>2013-06-25T21:32:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/06/25/java-deep-copy</id>
    <content type="html"><![CDATA[<h2>JAVA中的浅拷贝和深拷贝(shallow copy and deep copy)</h2>

<h3>一个示例</h3>

<p>首先要区分"copy a value"和"copy an object"之间的区别：</p>

<pre><code>// copy a value
int val   = 1;
int cpVal = val;

// copy a value(the object reference for the array above)
int[] val   = new int[]{42};
int[] cpVal = val;

// copy a object
StringBuffer object   = new StringBuffer("I am a object");
StringBuffer cpObject = new StringBuffer(object);
</code></pre>

<p>简单的说，赋值操作都是"copy a value"。如果想要"copy an object"，需要显式的或者在内部进行类似"new"的操作。</p>

<h3>对象(object)的浅拷贝和深拷贝</h3>

<p>浅拷贝意味着仅仅拷贝对象的一层，而深拷贝意味着拷贝对象对于一层的数据。那么问题就是，怎么去定义一层？</p>

<p>考虑下面的例子：</p>

<pre><code>public class Example {
    public int foo;
    public int[] bar;
    public Example() { };
    public Example(int foo, int[] bar) { this.foo = foo; this.bar = bar; };
}

Example eg1 = new Example(1, new int[]{1, 2});
</code></pre>

<p>下面两个例子分别执行了对eg1的<strong>浅拷贝和深拷贝</strong>：</p>

<pre><code>Example eg2 = new Example(eg1.foo, eg1.bar);
Example eg2 = new Example(eg1.foo, Arrays.copy(eg1.bar));
</code></pre>

<h3>clone方法</h3>

<p>每一个类和array都包含这个方法，它的功能是创建目的对象的一个拷贝，然而要注意以下几点：</p>

<ul>
<li>deep无法确定到底是多少层？两层？三层？还是所有链接的对象</li>
<li>实际上，文档并没有说明clone是否创建一个新的对象</li>
</ul>


<p>下面是javadoc对于clone的解释：</p>

<pre><code>"Creates and returns a copy of this object. 
The precise meaning of "copy" 
may depend on the class of the object. 

The general intent is that, for any object x, 
the expression x.clone() != x will be true, 
and that 
the expression x.clone().getClass() == x.getClass() 
will be true, 
but these are not absolute requirements. 

While it is typically the case that 
x.clone().equals(x) will be true, 
this is not an absolute requirement."
</code></pre>

<h3>Java List深拷贝实现</h3>

<p>使用List的addAll方法就可以deep copy源列表中的所有元素(前提是list内部元素执行浅拷贝即可)：</p>

<pre><code>public static void main(String[] args) {

    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    list.add("1");
    list.add("2");

    // 创建dest list，将源list的所有值都拷贝过去
    List&lt;String&gt; dest = new ArrayList&lt;String&gt;();
    dest.addAll(list);

    // 在dest list中添加一个元素，修改一个元素
    dest.add("3");
    dest.set(0, "2");

    // 打印两个数组
    for (String item : list) {
        System.out.println(item);
    }
    System.out.println("--------------------------------");
    for (String item : dest) {
        System.out.println(item);
    }
    System.out.println("--------------------------------");
}
</code></pre>

<p>输出：</p>

<pre><code>1
2
--------------------------------
2
2
3
--------------------------------
</code></pre>

<h3>参考</h3>

<p><a href="http://stackoverflow.com/questions/6182565/java-deep-copy-shallow-copy-clone">Java :deep copy, shallow copy, clone</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAVA HashTable & HashMap & ...]]></title>
    <link href="http://zhangdian.github.com/blog/2013/06/14/java-hashtable-hashmap/"/>
    <updated>2013-06-14T22:05:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/06/14/java-hashtable-hashmap</id>
    <content type="html"><![CDATA[<h2>HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</h2>

<p>经常用到HashMap，也经常听到HashTable和HashMap之间的故事，故google了一番，总结一下常用的各种Map。</p>

<h3>概述</h3>

<p>HashMap：实现上和HashTable相似，并且keys和values是无序的</p>

<p>TreeMap：基于红黑树结构实现，并且key是排好序的</p>

<p>LinkedHashMap：保持插入时的顺序</p>

<p>HashTable：和HashMap相比，是线程安全的</p>

<p>ConcurrentHashMap：相比HashMap，是线程安全的，但是推荐使用它来替代HashTable，因为性能更高，具体见后面</p>

<!-- more -->


<h3>HashMap</h3>

<p>如果HashMap的key是自定义的话，需要重载hashcode和equals方法。因为在HashMap中，不允许有两个完全相同的元素的存在。默认情况下，会使用Object类的hashcode和equals方法。其中，hashcode方法中，不同的对象返回不一样的整数，equals方法只在两个对象引用同一个对象时返回true。</p>

<p>在<a href="http://www.programcreek.com/2011/07/java-equals-and-hashcode-contract/">参考2</a>中，详细讲解了hashcode和equals的原理：</p>

<pre><code>在一个HashMap中查找一个元素的时候，
首先会调用HashCode方法，寻找相应的桶位，
然后在这个桶对应的array中，线性寻找，调用equals方法进行比较，
直到遍历完这个array，或者找到待查的元素。
另外，在该示例中，详细给出了equals和hashcode方法是实现示例。
</code></pre>

<h3>HashMap vs HashTable</h3>

<p>经常听到关于HashMap和HashTable的言论，Java Doc上说：</p>

<pre><code>From Java Doc:  The HashMap class is roughly equivalent to Hashtable, 
except that it is unsynchronized and permits nulls.
</code></pre>

<p>也就是说，两者几乎是一样的一样的，只是HashMap不是线程安全的，并且允许在keys和values中出现null值。</p>

<p>而java5中，也用ConcurrentHashMap来替代了HashTable，两者使用的锁机制是不一样的。</p>

<p>Hashtable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能由一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。上面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个hash表。</p>

<h3>TreeMap</h3>

<p>TreeMap是根据key来进行排序的，必须实现Comparable接口，实现其中的方法：</p>

<pre><code>@Override
public int compareTo(Dog o) {
    return  o.size - this.size;
}
</code></pre>

<p>具体事例见<a href="http://java.dzone.com/articles/hashmap-vs-treemap-vs">参考1</a>。</p>

<h3>LinkedHashMap</h3>

<p>LinkedHashMap是HashMap的子类，意味着它继承了HashMap的属性。除此之外，它保存了元素插入的顺序。</p>

<h3>参考</h3>

<ol>
<li><a href="http://java.dzone.com/articles/hashmap-vs-treemap-vs">HashMap vs. TreeMap vs. HashTable vs. LinkedHashMap</a></li>
<li><a href="http://www.programcreek.com/2011/07/java-equals-and-hashcode-contract/">Java equals() and hashCode() Contract – Code Example</a></li>
<li><a href="http://developer.51cto.com/art/201102/246431.htm">Hashtable和HashMap引发的血案</a></li>
<li><a href="http://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable">Differences between HashMap and Hashtable?</a></li>
<li><a href="http://blog.csdn.net/itm_hadf/article/details/7506529">java集合框架【3】 java1.5新特性 ConcurrentHashMap、Collections.synchronizedMap、Hashtable讨论</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_5157093c0100hm3y.html">SynchronizedMap和ConcurrentHashMap的深入分析</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java定时任务]]></title>
    <link href="http://zhangdian.github.com/blog/2013/06/14/java-schedule-task/"/>
    <updated>2013-06-14T21:56:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/06/14/java-schedule-task</id>
    <content type="html"><![CDATA[<h2>定时任务</h2>

<h3>关于定时任务</h3>

<p>定时任务有两种：</p>

<ul>
<li>固定延时的定时任务，即一个任务结束等待固定时间后再执行下一个；</li>
<li>固定频率的定时任务，即任务在固定时常后开始执行。</li>
</ul>


<p>前者的意思是，任务完成之后，等待固定的诗句再执行下一个；而后者的意思是在固定的时间执行任务，如果前一次任务的结束时间已经超过了下一次任务开始的时间，那么就会立即执行。</p>

<!-- more -->


<h3>定时任务实现方案</h3>

<p>Timer和ScheduledThreadPoolExecutor都可以完成定时任务的工作，也都支持上面的两种方式。</p>

<p>下面分别给出两个类的示例：</p>

<pre><code>package com.concurrent.basic;
import java.util.Timer;
import java.util.TimerTask;
public class TimerTest {
    private Timer timer = new Timer();

    // 启动计时器
    public void lanuchTimer() {
        timer.schedule(new TimerTask() {
            public void run() {
                // do sth...
            }
        }, 1000 * 3, 500);
    }

    public static void main(String[] args) throws Exception {
        TimerTest test = new TimerTest();
        test.lanuchTimer();
    }
}
</code></pre>

<p>这个例子是固定延时的任务，详细文档见<a href="http://docs.oracle.com/javase/7/docs/api/">Timer</a>，文档中，也有scheduleAtFixedRate方法来调用固定频率的任务。</p>

<pre><code>package com.concurrent.basic;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorTest {

    public ScheduledExecutorService scheduExec = Executors
            .newScheduledThreadPool(1);

    // 启动计时器
    public void lanuchTimer() {
        Runnable task = new Runnable() {
            public void run() {
                // do sth...
            }
        };
        scheduExec.scheduleWithFixedDelay(task, 1000 * 5, 1000 * 10,
                TimeUnit.MILLISECONDS);
    }

    public static void main(String[] args) throws Exception {
        ScheduledExecutorTest test = new ScheduledExecutorTest();
        test.lanuchTimer();
    }
}
</code></pre>

<p>这个例子是固定延时的任务示例，也可以调用scheduleAtFixedRate方法来启用固定频率的任务。</p>

<h3>比较</h3>

<ul>
<li>Timer对系统时钟是敏感的，而ScheduledThreadPoolExecutor不是；</li>
<li>Timer只有一个执行线程，所以如果一个线程延时太久了，会影响其他的固定延时任务。而ScheduledThreadPoolExecutor可以配置任意数量的线程，并且你可以完成控制你所创建的这些线程；</li>
<li><em>在Timer中，运行时错误会直接杀死线程，也就会导致线程挂掉，后面计划的任务也不会执行。ScheduledThreadPoolExecutor不仅可以给你catch住运行时异常，还可以对它们进行处理。抛出异常的任务会挂掉，但是其他的定时任务会继续执行。</em></li>
</ul>


<h3>相关链接</h3>

<ul>
<li><a href="http://marshal.easymorse.com/archives/3136">通过java concurrent实现定时任务</a></li>
<li><a href="http://batitan.iteye.com/blog/253483">定时任务:Java中Timer和TimerTask的使用</a></li>
<li><a href="http://stackoverflow.com/questions/409932/java-timer-vs-executorservice">Java Timer vs ExecutorService?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring WEB MVC总结]]></title>
    <link href="http://zhangdian.github.com/blog/2013/05/27/spring-web-mvc/"/>
    <updated>2013-05-27T00:26:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/05/27/spring-web-mvc</id>
    <content type="html"><![CDATA[<p>用了这么久的spring web，终于把官方的文档看了看，总结出来下面的文档。</p>

<!-- more -->


<h4>Spring WEB MVC的特性</h4>

<ul>
<li>角色分明：controller、validator、command object、form object、model object、DispatcherServlet、handler mapping、view resolver等等，每个角色都可以由一个专门的对象来实现；</li>
<li>框架和类似JavaBean应用类的强大而简单的配置；</li>
<li>适配性、非侵入性以及灵活性。可以任意定义controller方法的前面，对于指定的场景，可以使用@RequestParam、@RequestHeader、@PathVariable其中的一个；</li>
<li>可重用的业务代码；</li>
<li>可定制话的绑定和验证；</li>
<li>类型匹配错误作为应用层的验证错误，取代手动将传进来的String-Only对象parse and convert成为业务对象；</li>
<li>个性化handler mapping以及view resolution；</li>
<li>灵活的model解析。利用name/value Map，可以利用任意一种view技术解析model；</li>
<li>个性化的locale以及theme resolution。支持JSPs，包不包含Spring tag lib，JSTL都行；</li>
<li>等等</li>
</ul>


<h4>其他MVC实现的可插入性</h4>

<p>如果不想使用Spring web MVC，而是想在其他类似struts、WebWork的框架中使用Spring的某些特性，这也是可以的，具体的可以查看相关文档。</p>

<h4>1. DispatcherServlet类</h4>

<p>和其他的MVC框架一样，Spring web MVC也是基于<strong>请求驱动</strong>的模型，围绕一个核心的servlet，将所有的请求分发到Controllers，同时提供丰富的功能，来帮助web应用程序的开发。Spring完全集成Spring IoC容器，允许你使用Spring所拥有的任何特性。</p>

<p>下图是Spring web MVC中的请求处理流程图：</p>

<p><img src="https://dl.dropboxusercontent.com/u/99113526/blog.bd17kaka.net/spring-web-mvc.png"></p>

<p>DispatcherServlet是Servlet类的一个子类，继承自HttpServlet，它在web.xml文件中进行定义。需要通过使用URL映射，来将需要其处理的请求映射到这个Servlet。下面是一个标准的servlet配置：</p>

<p>```</p>

<!-- web.xml -->


<p><web-app></p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;example&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;example&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p></web-app>
```</p>

<p>额外的参数：contextClass、contextConfigLocation、namespace，具体解释见原文。</p>

<p>在这个例子中，所有满足表达式“*.form”的请求，都将有servlet-name为“example”的这个servlet来进行处理。</p>

<p>在Spring中，ApplicationContext实例是有作用域的。在Web MVC架构中，每一个DispatcherServlet类都有它自己的WebApplicationContext，这个WebApplicationContext继承所有已经在根部的WebApplicationContext中所定义的beans。这些beans是可以被在servlet中定义的beans所覆盖的。（不太懂，得看看Spring Ioc）</p>

<p>在DispatcherServlet初始化的时候，Spring在文件夹WEB-INF中查找文件名为[servlet-name]-servlet.xml的文件，并且创建那个文件里面定义的所有beans。将在全局作用域中，有相同名称的bean全覆盖掉。</p>

<p>考虑上面的那个web.xml定义，那么需要在WEB-INF文件夹中，创建一个名为example-servlet.xml的文件，这个里面包含所有Spring WEB MVC所拥有的beans。</p>

<p><strong>我的理解是：一个web.xml文件中可以定义多个servlet；一个servlet对应一个example-servlet.xml文件；一个example-servlet.xml文件就是一个WebApplicationContext。</strong></p>

<p>在WebApplicationContext中，包含下面这些类型的beans：</p>

<ul>
<li>controllers</li>
<li>handler mappings</li>
<li>view resolvers</li>
<li>locale resolvers</li>
<li>theme resolver</li>
<li>multipart file resolver</li>
<li>handler exception resolvers</li>
</ul>


<p>当有一个请求到来的时候，DispatcherServlet是按照以下的顺序来处理这个请求的：</p>

<ul>
<li>搜索WebApplicationContext，并且将其作为一个attribute绑定到request中，这样，在这个过程中，controller和其他的元素都可以使用。默认情况下，它被绑定在DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE里面；</li>
<li>locale resolver绑定到request中，这样，其他的元素可以解析并使用locale（呈现view、准备数据等等）。如果你不需要locale resolving，那么就不需要他它；</li>
<li>theme resolver绑定到request中，允许views等元素决定使用哪个theme。如果不需要themes，可以忽略它；</li>
<li>如果指定了一个multipart file resolver，那么这个请求就被看做multipart。如果找到了multipart，就会将这个请求包装成一个MultipartHttpServletRequest，再由其它元素进行进一步的处理；</li>
<li>搜索一个合适的handler。如果找到了，那个和这个handler相关的执行链（preprocessors, postprocessors, and controllers）会被执行，以准备model以及呈现；</li>
<li>如果返回了一个model，那么会呈现一个view；如果没有model返回，那么不会呈现任何view，因为请求以及被执行完毕了。</li>
</ul>


<p>在WebApplicationContext中声明的Handler exception resolvers对象，接收在请求处理过程中产生的所有错误。用这些exception resolvers可以使对于不同的exception定义个性化的处理办法。</p>

<h4>2. Controllers</h4>

<p>controllers获取用户的输入，并且在处理之后，将其转换为model，进而转换为view，展现给用户。Spring提供的controller是非常抽象化的，可以定义各种各样、大量的controllers。</p>

<p>Spring2.5引入基于注解的编程模型，可以使用诸如@RequestMapping、@RequestParam、@ModelAttribute等注解。它同时支持Servlet MVC和Potlet MVC。这种情况下，不需要事先指定的基类或者指定的接口。下面是一个简单的例子：</p>

<p>```
@Controller
public class HelloWorldController {</p>

<pre><code>@RequestMapping("/helloWorld")
public ModelAndView helloWorld() {
    ModelAndView mav = new ModelAndView();
    mav.setViewName("helloWorld");
    mav.addObject("message", "Hello World!");
    return mav;
}
</code></pre>

<p>}</p>

<p>```</p>

<h5>2.1 使用@controller定义一个controller</h5>

<p>@controller标签定义一个执行controller功能的类，在Spring里面，不需要继承任何的controller基类，或者调用ServletAPI，不过，如果有需要的话，也可以调用Servlet指定的特性。</p>

<p>@controller作为被注解的类的签名，标示这个类的角色。Dispatcher类扫描以@controller做注解的类，然后寻找以@RequestMapping做注解的方法。</p>

<p>我们可以严格的对controller类使用@controller注解，但是@controller标签页支持自动搜索，依赖于Spring支持在classpath中自动搜索组件类，以及为他们完成自动注册的bean的定义。</p>

<p>只需要将扫描组件添加到配置中，即可启用自动扫描这样的注解controller的功能：</p>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:p="http://www.springframework.org/schema/p" 
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="
    http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

&lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/&gt;

// ...
</code></pre>

<p></beans>
```</p>

<h5>2.2 利用@RequestMapping来匹配请求</h5>

<p>我们可以用类似于“/handler”的注解来匹配整个类，也可以只匹配某个函数。比如，对于一个指定的HTTP请求（GET/POST）或者一个HTTP请求参数，我们经常用一个<strong>类级别</strong>的注解来将一个指定的请求映射到一个表单controller，然后使用一个额外的<strong>方法级别</strong>的注解来缩小范围。下面是一个例子：</p>

<p>```
@Controller
@RequestMapping("/handler")
public class AppointmentsController {</p>

<pre><code>private final AppointmentBook appointmentBook;

@Autowired
public AppointmentsController(AppointmentBook appointmentBook) {
    this.appointmentBook = appointmentBook;
}

@RequestMapping(method = RequestMethod.GET)
public Map&lt;String, Appointment&gt; get() {
    return appointmentBook.getAppointmentsForToday();
}

@RequestMapping(value="/{day}", method = RequestMethod.GET)
public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) {
    return appointmentBook.getAppointmentsForDay(day);
}

@RequestMapping(value="/new", method = RequestMethod.GET)
public AppointmentForm getNewForm() {
    return new AppointmentForm();
}

@RequestMapping(method = RequestMethod.POST)
public String add(@Valid AppointmentForm appointment, BindingResult result) {
    if (result.hasErrors()) {
        return "appointments/new";
    }
    appointmentBook.addAppointment(appointment);
    return "redirect:/appointments";
}
</code></pre>

<p>}
```</p>

<p>类级别的@RequestMapping注解并不是必须的，没有它的话，所有路径都是绝对路径，而不是相对路径。</p>

<p>这里有一个当使用proxy时，关于@controller注解类的小陷阱，具体内容见原文。</p>

<h6>2.2.1 URI模板</h6>

<p>如果想要访问URL中的某个部分，那么就可以在@RequestMapping的路径变量中使用URL模板。</p>

<p>在函数中使用@PathVariable注解时，意味着函数的这个变量需要绑定到URI模板变量的某个部分。</p>

<p>例如：</p>

<p><code>
@RequestMapping(value="/owners/__{ownerId}__", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
  Owner owner = ownerService.findOwner(ownerId);  
  model.addAttribute("owner", owner);  
  return "displayOwner";
}
</code></p>

<p>如果代码编译是在启用debugging模式下进行的，那么路径中的ownerId的值会被设置到函数变量ownerId中；如果没有启用debugging模式，那么必须给函数变量指定它要映射到的路径变量的名称，例如：</p>

<p>```
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(<strong>@PathVariable("ownerId")</strong> String ownerId, Model model) {
  // implementation omitted
}</p>

<p>```</p>

<p>也就是说，在没有启用debugging模式的时候，路径中的变量是可以和函数声明中的变量按名称来进行匹对，进而赋值的；在没有启用debugging模式的时候，必须要指定与函数签名中的变量进行匹对的路径中的变量的名称。所以在没有启用debugging的时候，下面的写法也是而已的：</p>

<p><code>
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String __theOwner__, Model model) {
  // implementation omitted
}
</code></p>

<p>当然也可以指定多个路径变量：</p>

<p><code>
@RequestMapping(value="__/owners/{ownerId}/pets/{petId}__", method=RequestMethod.GET)
public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
  Owner owner = ownerService.findOwner(ownderId);  
  Pet pet = owner.getPet(petId);  
  model.addAttribute("pet", pet);  
  return "displayPet";
}
</code></p>

<p>下面的实例演示了相对路径的用法：</p>

<p>```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {</p>

<p>  @RequestMapping("/pets/{petId}")
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {</p>

<pre><code>// implementation omitted
</code></pre>

<p>  }
}</p>

<p>```</p>

<p><strong>注意：@PathVariable中声明的变量可以是任意类型的，Spring会进行自动的类型转换，如果转换失败的话，会抛出TypeMismatchException异常。我们也可以通过定制data binder来定制这个转换的过程，具体见后面。</strong></p>

<h6>2.2.2 @RequestMapping的更多选项</h6>

<p>除了URI模板之外，@RequestMapping同样支持正则，比如<code>/myPath/*.do</code>，URI路径和正则的组合也是支持的（<code>/owners/*/pets/{petId}</code>）。</p>

<p>如果没有严格匹配的方法来处理请求，那么处理方法的名称用于缩小范围。如果有多个这样的方法，那么就会在这些方法里面进行选择。</p>

<p>可以通过类似于<code>myParam=myValue</code>的参数条件来缩小路径匹配的范围。比如：</p>

<p>```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {</p>

<p>  @RequestMapping(value = "/pets/{petId}", <strong>params="myParam=myValue"</strong>)
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {</p>

<pre><code>// implementation omitted
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>“myParam”这种形式的表达式也是允许的，意思是参数myParam存在于请求路径中，同样的，“！myParam”的意思是参数myParam不存在与请求路径中。</p>

<p>相似的，也可以通过比较header的信息来缩小路径匹配的范围：</p>

<p>```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {</p>

<p>@RequestMapping(value = "/pets", method = RequestMethod.POST, <strong>headers="content-type=text/*"</strong>)
  public void addPet(Pet pet, @PathVariable String ownerId) {</p>

<pre><code>// implementation omitted
</code></pre>

<p>  }
}
```</p>

<h6>2.2.3 处理方法支持的参数和返回值类型</h6>

<p>被@RequestMapping注解的处理方法可以有非常灵活的签名，他们中的很多都可以以任意的顺序所使用。</p>

<ul>
<li>Request和Response对象（Servlet API）：选择任意指定的request或者response类型，比如ServletRequest和HttpServletRequest；</li>
<li></li>
</ul>

]]></content>
  </entry>
  
</feed>
