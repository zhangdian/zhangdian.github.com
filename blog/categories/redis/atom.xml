<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redis | bd17kaka's blog]]></title>
  <link href="http://zhangdian.github.com/blog/categories/redis/atom.xml" rel="self"/>
  <link href="http://zhangdian.github.com/"/>
  <updated>2012-12-13T10:06:07+08:00</updated>
  <id>http://zhangdian.github.com/</id>
  <author>
    <name><![CDATA[bd17kaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis文档]]></title>
    <link href="http://zhangdian.github.com/blog/2012/12/13/redis-docs/"/>
    <updated>2012-12-13T09:27:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2012/12/13/redis-docs</id>
    <content type="html"><![CDATA[<h3>1. Redis介绍</h3>

<h4>1.1 什么是redis</h4>

<p>REmote DIctionary Server(Redis)是一个由Salvatore Sanfilippo写的key-value存储系统。Redis提供了一些丰富的数据结构，包括lists，sets，ordered sets以及hashes，当然还有和Memcached一样的strings结构。Redis当然还包括了对这些数据结构的丰富操作。</p>

<h4>1.2 redis的优点</h4>

<ul>
<li>性能极高：Redis能支持超过 100K+ 每秒的读写频率；</li>
<li>丰富的数据类型：Redis支持二进制安全的Strings，Lists，Hashes，Sets及Ordered Sets数据类型操作；</li>
<li><strong>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行；</strong></li>
<li>丰富的特性：Redis还支持 publish/subscribe，通知，key过期等等特性。</li>
</ul>


<!-- more -->


<h3>2. Redis的数据类型</h3>

<p>redis使用的是key作为存取对象的唯一标识，对“key”的通俗理解就是“字符串”。在Redis中字符串又分为两类：二进制安全(Binary Safe)的和非二进制安全的，关于二进制安全的描述可以参考<a href="http://en.wikipedia.org/wiki/Binary_safe">binary safe</a>。Redis处理存储的内容时用的是二进制安全的字符串，而作为key使用的非二进制安全的。</p>

<h4>2.1 String</h4>

<h5>2.1.1 String的结构</h5>

<p>redis string的实现包含在sds.c文件中，redis string的定义在sdshdr.h文件中：</p>

<p>```
struct sdshdr {</p>

<pre><code>long len;
long free;
char buf[];
</code></pre>

<p>};
// len代表buf中实际保存的字符串的长度，那么就可以再O(1)的时间内获取字符串的长度
// free代表buf中还剩余的空间长度
// 保存实际的字符串
// len + free 等于buf数组的长度
```</p>

<h5>2.1.2 String的创建</h5>

<p>在sds.h中定义了一个新的类型，实际上类型sds就是字符串指针的一个别名而已。</p>

<p><code>
typedef char *sds;
</code></p>

<p>在sds.c中定义的sdsnewlen函数创建一个新的字符串：</p>

<p>```
sds sdsnewlen(const void *init, size_t initlen) {</p>

<pre><code>struct sdshdr *sh;

sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
</code></pre>

<h1>ifdef SDS_ABORT_ON_OOM</h1>

<pre><code>if (sh == NULL) sdsOomAbort();
</code></pre>

<h1>else</h1>

<pre><code>if (sh == NULL) return NULL;
</code></pre>

<h1>endif</h1>

<pre><code>sh-&gt;len = initlen;
sh-&gt;free = 0;
if (initlen) {
    if (init) memcpy(sh-&gt;buf, init, initlen);
    else memset(sh-&gt;buf,0,initlen);
}
sh-&gt;buf[initlen] = '\0';
return (char*)sh-&gt;buf;
</code></pre>

<p>}
```</p>

<p>可以看到，函数介绍两个参数，一个是字符串指针，一个是字符串长度。然后分配一个地址空间，包括三个部分：struct sdshdr长度、字符串长度以及字符串最后的结尾符。最后对struct sdshdr的各个元素赋值，返回其buf部分，也就是实际的字符串。</p>

<p>假设使用如下代码初始化它，那么内存结构大概是下面这个样子的：</p>

<p>```
// 初始化
sdsnewlen("bd17kaka", 8);</p>

<h2>// 结果</h2>

<h2>|8|0|bd17kaka|</h2>

<p>^   ^
sh  sh->buf</p>

<p>```</p>

<h5>2.1.3 通过buf指针获取sh指针</h5>

<p>从上面的内存结构图可以看到，buf的内存地址实际上只比sh的内存地址多了len和free两个变量的长度，也就是两个long的长度，实际上就是struct sdshdr的长度，那么可以通过以下方法获取sh的指针：</p>

<p>```
struct sdshdr <em>sh = (void</em>) (s-(sizeof(struct sdshdr)));</p>

<p>// 获取字符串的长度
size_t sdslen(const sds s) {</p>

<pre><code>struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
return sh-&gt;len;
</code></pre>

<p>}
```</p>

<p>在redis源代码其他地方，可以经常看到这个技巧的使用。</p>

<h4>2.2 List</h4>

<h4>2.3 set（集合）</h4>

<h4>2.4 sorted set（有序集合）</h4>

<h4>2.5 hash</h4>

<h3>3. Publish/Subscribe</h3>

<h3>4. 数据过期</h3>

<h3>5. 事务性</h3>

<h3>6. 持久化</h3>

<h3>7. 管理</h3>
]]></content>
  </entry>
  
</feed>
