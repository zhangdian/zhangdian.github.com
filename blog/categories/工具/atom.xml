<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 工具 | bd17kaka's blog]]></title>
  <link href="http://zhangdian.github.com/blog/categories/工具/atom.xml" rel="self"/>
  <link href="http://zhangdian.github.com/"/>
  <updated>2013-03-27T23:34:02+08:00</updated>
  <id>http://zhangdian.github.com/</id>
  <author>
    <name><![CDATA[bd17kaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[rabbitMQ]]></title>
    <link href="http://zhangdian.github.com/blog/2013/03/27/rabbitmq/"/>
    <updated>2013-03-27T17:02:00+08:00</updated>
    <id>http://zhangdian.github.com/blog/2013/03/27/rabbitmq</id>
    <content type="html"><![CDATA[<h3>RabbitMQ</h3>

<p>RabbitMQ是一个消息代理，它接收和转发消息。它有六种模式，下面介绍其中的四种模式。</p>

<!-- more -->


<h4>1. 最简单的模式</h4>

<p><img src="https://dl.dropbox.com/u/99113526/blog.bd17kaka.net/rabbitmq-1.png"></p>

<h5>1.1 角色</h5>

<ul>
<li>生产者(Producing)除了发送消息之外，什么也不做，用“P”表示；</li>
<li>所有消息都存储在Queue里面，所有消息都流经Queue以及我们的应用程序。Queue没有任何限制，它可以存储尽可能多的消息，本质上，它是一个无穷大(infinite)的buffer；</li>
<li>消费者(Consumer)等待接收消息，用“C”表示。</li>
</ul>


<p>这三个角色没必要在一个机器上，实际上也是这样的。</p>

<h5>1.2 生产者</h5>

<p>生产者发送消息的时候，一定要保证Queue的存在，如果它发送消息到一个不存在的Queue，RabbitMQ会丢弃掉这个消息。</p>

<p><code>
channel.queue_declare(queue='hello')
</code></p>

<p>RabbitMQ中，消息实际上不会直接发送到Qeueu上，而是先发送到Exchange上，不指定Exchange的话，会发送到默认的Exchange（“”，空字符串）上。</p>

<p>需要在routing_key参数中指定Queue的名称：</p>

<p>```
channel.basic_publish(exchange='',</p>

<pre><code>                  routing_key='hello',
                  body='Hello World!')print " [x] Sent 'Hello World!'"
</code></pre>

<p>```</p>

<p>退出之前，需要确保清空缓存，并且所有的消息都发送到RabbitMQ：</p>

<p><code>
connection.close()
</code></p>

<h5>1.3 消费者</h5>

<p>首先要连接到服务器，其次，要保证Queue的存在，使用queue_declare创建Queue是幂等的（idempotent，也就是多次创建，只会有一个同一名字的Queue被创建），所以，重新声明一个Queue永远是比较好的。</p>

<p><code>
channel.queue_declare(queue='hello')
</code></p>

<p>RabbitMQ通过注册一个回调函数来接收消息，每次接收到一个消息的时候，都会调用回调函数。其次，需要指定消费者从指定的Queue来接收消息：</p>

<p>```
def callback(ch, method, properties, body):</p>

<pre><code>print " [x] Received %r" % (body,)
</code></pre>

<p>channel.basic_consume(callback,</p>

<pre><code>                  queue='hello',
                  no_ack=True)
</code></pre>

<p>```</p>

<p>为了保证正确的读取消息，要保证Queue的存在，只要我们在生产者端创建了Queue，那么就可以保证这点。</p>

<p>然后，就会进入到一个永远都不会停止的循环，只要有消息都会调用回调函数。</p>

<h4>2. One producer, multi consumer</h4>

<p><img src="https://dl.dropbox.com/u/99113526/blog.bd17kaka.net/rabbitmq-2.png"></p>

<p>continue...</p>
]]></content>
  </entry>
  
</feed>
